% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_gofLMM.R
\name{gof.lmm.O.type2}
\alias{gof.lmm.O.type2}
\title{Goodness-of fit test for LMM}
\usage{
gof.lmm.O.type2(fit, residuals = c("individual", "cluster"),
  std.type = c(1, 2), use.correction.for.imbalance = FALSE,
  type = c("sign.flip", "permutation"), M = 100,
  order.by.original = FALSE, verbose = FALSE)
}
\arguments{
\item{fit}{The result of a call to \code{"nlme"}. The model must be fitted with \code{control=lmeControl( returnObject = TRUE)} and \code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!}

\item{residuals}{Residuals to be used when constructing the process. Possible values are \code{"individual"} and \code{"cluster"} for \textit{individual} and \textit{cluster-speciffic} residuals, respectively.}

\item{std.type}{Type of standardization to be used for the residuals when constructing the process.
Currently implemeneted options are \code{1} and \code{2} for $S_i=\hat\sigma^{-1/2}I_{n_i}$ and $S_i=\hat{V}_i^{-1/2}$.}

\item{use.correction.for.imbalance}{Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \code{FALSE}.}

\item{type}{How to obtain the processes $W^m$. Possible values are  \code{"sign.flip"} for the sign-flipping approach and \code{"permutation"} for the permutation approach.}

\item{M}{Number of random simulations/sign-flipps/permutations. Defaults to \code{100}.}

\item{order.by.original}{Logical. Should the residuals in the the processes $W^m$ be ordered by the original fitted values? Defaults to \code{FALSE}.}

\item{verbose}{Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \code{FALSE}.}
}
\value{
An object of class \code{"gofLMM"} for which \code{plot} and \code{summary} functions are available.
}
\description{
Goodness-of fit test based on cumulative sum stochastic process for O and John's idea. Not well tested!
}
\examples{
# simulate some data:
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=TRUE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){

  id<-c(id,rep(gg,each=n[gg]))
  x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
  x1<-c(x1,x11)

  if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept

  b<-rep(re.int,each=n[gg])

  if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope

  b2<-rep(re.slope,each=n[gg])
  x2<-1:n[gg]
  x4<-runif(n[gg])

  if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale

  if (sim.re.slope==TRUE) {
    if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
  } else {
    if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
  }
  yy<-c(yy,y)
 x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~1|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof<-gof.lmm.O.type2(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,type= "permutation" ,M=100,order.by.original=FALSE,verbose=TRUE)
fit.gof$KS
fit2<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof2<-gof.lmm.O.type2(fit2,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,type= "permutation" ,M=100,order.by.original=FALSE,verbose=TRUE)
fit.gof2$KS
fit3<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x1|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof3<-gof.lmm.O.type2(fit3,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,type= "permutation" ,M=100,order.by.original=FALSE,verbose=TRUE)
fit.gof3$KS
}
\seealso{
\code{\link{gof.lmm.pan}}, \code{\link{gof.lmm.sim}}
}
\author{
Rok Blagus, \email{rok.blagus@mf.uni-lj.si}
}
