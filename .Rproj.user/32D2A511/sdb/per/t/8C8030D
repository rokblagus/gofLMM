{
    "collab_server" : "",
    "contents" : "\n#####example with functions from package\n\nlibrary(gofLMM)\nlibrary(mvtnorm)\nlibrary(nlme)\n\n\npdf(\"FiguresimExFunPackage2.pdf\",height=10,width=10)\n\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=500\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\n\n\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\n\n####model 1\n\nfit<-lme(y~X2,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"A) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"B) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n####model 2\n\nfit<-lme(y~X2+X3,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"C) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"D) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\n####model 3\n\nfit<-lme(y~X2+X3,random=~X2|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"E) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"F) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\ndev.off()\n\n\n\nlibrary(gofLMM)\nlibrary(mvtnorm)\nlibrary(nlme)\n\n\npdf(\"FiguresimExFunPackage2cluster.pdf\",height=10,width=10)\n\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=500\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\n\n\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\n  eps<-rnorm(n,sd=sqrt(var.fe))\n\n  Zi<-x[id==ii,which(sim.random.effects==1) ]\n\n  re<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\n  y<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\n\n####model 1\n\nfit<-lme(y~X2,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\n#fas<-gof.lmm.sim.orderbyoriginal(fit, std.type = 2,use.correction.for.imbalance = FALSE, M = 500, verbose = FALSE)\n\nfit.gof<-gof.lmm(fit,residuals= \"cluster\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"A) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"B) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n####model 2\n\nfit<-lme(y~X2+X3,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"cluster\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"C) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"D) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\n####model 3\n\nfit<-lme(y~X2+X3,random=~X2|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"cluster\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"E) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"F) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\ndev.off()\n\n\n\npdf(\"FiguresimExSimPackageSimSim.pdf\",height=10,width=10)\n\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=500\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\n\n\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\n  eps<-rnorm(n,sd=sqrt(var.fe))\n\n  Zi<-x[id==ii,which(sim.random.effects==1) ]\n\n  re<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\n  y<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\n\n####model 1\n\nfit<-lme(y~X2,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"simulation\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"A) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"B) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n####model 2\n\nfit<-lme(y~X2+X3,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"C) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"D) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\n####model 3\n\nfit<-lme(y~X2+X3,random=~X2|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"E) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"F) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\ndev.off()\n\n\n\n\n\npdf(\"FiguresimExSimPackageSimPan.pdf\",height=10,width=10)\n\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=500\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\n\n\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\n  eps<-rnorm(n,sd=sqrt(var.fe))\n\n  Zi<-x[id==ii,which(sim.random.effects==1) ]\n\n  re<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\n  y<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\n\n####model 1\n\nfit<-lme(y~X2,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm.pan(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,M=500,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"A) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"B) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n####model 2\n\nfit<-lme(y~X2+X3,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm.pan(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,M=500,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"C) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"D) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\n####model 3\n\nfit<-lme(y~X2+X3,random=~X2|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm.pan(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,M=500,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"E) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"F) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\ndev.off()\n\n\n\n\n####figure for our simulation approach\n\nlibrary(gofLMM)\nlibrary(mvtnorm)\nlibrary(nlme)\n\n\npdf(\"FiguresimExSim.pdf\",height=10,width=10)\n\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=500\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\n\n\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\n\n####model 1\n\nfit<-lme(y~X2,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"simulation\" ,M=500,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"A) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"B) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n####model 2\n\nfit<-lme(y~X2+X3,random=~1|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"simulation\" ,M=500,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"C) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"D) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\n####model 3\n\nfit<-lme(y~X2+X3,random=~X2|id,data=df,control=lmeControl( returnObject = TRUE),method=\"REML\")\n\nfit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"simulation\" ,M=500,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)\n\nsm<-summary(fit.gof)\n#plot(fit.gof)\n\nplot.gofLMM.part(fit.gof$O,fit.gof$Om,type=2,fit.gof$predO,fit.gof$predOm,xlab=\"\",ylab=txt1,main=paste(\"E) KS=\",round(sm[1,2],4),\" CvM=\",round(sm[2,2],4),sep=\"\"))\nplot.gofLMM.part(fit.gof$F,fit.gof$Fm,type=2,fit.gof$predF,fit.gof$predFm,xlab=\"\",ylab=txt2,main=paste(\"F) KS=\",round(sm[3,2],4),\" CvM=\",round(sm[4,2],4),sep=\"\"))\n\n\ndev.off()\n\n\n\n\n\n\n###########################################\n\n##########################old versions\n\n\n##will this be the final try?\n\n\n\nlibrary(MASS)\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nsign.flip<-TRUE #should not matter\n#permute.within<-TRUE #theory is made for TRUE, I made sims for false. makes sense only if sign.flip<-FALSE\nflip.cluster<-FALSE # the same number is applied to all subjects within the cluster (theory says this is the only valid way...)\n\nindividual<-FALSE  #by theory it should only be FALSE!\n\norder.by.original<-TRUE #use original fitted value instead of permuted. should in theory maybe only make sense for sign-flipping. setting to TRUE makes no sense at all\n\nind.proc<-FALSE #should not matter what you use\n\n\n\n\n\npdf(\"FiguresimExFinalScaledFinalLastFinalRokfinalNotCenteredDifStatSoHelpUsGod.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\n\n\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\nxo<-x\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n\n####model 1\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\n\n\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\nif (ind.proc==TRUE) res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nif (ind.proc==FALSE) res.i.c[df$id==gg]<-resP[df$id==gg]- (A+B)%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\nres.i.c2<-resI\n\n\nif (std.type!=1){\nresIS2<-NA\nresIS22<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm22<-matrix(res.i.c2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm22<-V.i%*%resIm22\nresIS22<-c(resIS22,resISm22)\n\n}\n\nresIS2<-resIS2[-1]\nresIS22<-resIS22[-1]\n}\n\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS22[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\nif (individual==FALSE) resP<-resP else resP<-resI\nif (individual==FALSE) estP<-estP else estP<-estI\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(-0.5) else V.i<-V%^%(0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\n\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nif (sign.flip==FALSE) {\n\tif (permute.within==FALSE) smp<-sample(1:(n*N)) else {\n\t\t\t\t\tsmp<-matrix(1:(n*N),ncol=n,byrow=T)\n\t\t\t\t\tsmp<-c(apply(smp,1,sample))\n\t\t\t\t\t}\n\t\t } else {\n\n\tif (flip.cluster==FALSE)\tsmp<-sample(c(-1,1),size=n*N,replace=T) else smp<-rep(sample(c(-1,1),size=N,replace=T),each=n)\n\n\t}\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(0.5) else V.i<-V%^%(-0.5)\n\nif (sign.flip==TRUE){\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute*smp)[df$id==gg]))\n\n} else {\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n}\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nif ( order.by.original==FALSE)  estsI<-fitted(fits,level=1) else estsI<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nif ( order.by.original==FALSE)   estsP<-fitted(fits,level=0) else estsP<-fitted(fit,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs2<-ressI\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\nif (order.by.original==FALSE) {\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-ressP[df$id==gg]- (As+Bs)%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n\n} else {\n\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n\nif (ind.proc==TRUE) {\n\nJ.i<-sigma.est*V.i-A%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n} else {\n\nJ.i<-I-(A+B)%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n}\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-J.i%*%ressI[df$id==gg]\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-J.i%*%ressP[df$id==gg]\n\n}\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-NA\nressIS22<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\n\nresIms22<-matrix(res.i.cs2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms22<-V.i%*%resIms22\nressIS22<-c(ressIS22,resISms22)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS22<-ressIS22[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS22[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\nres<-c(pKS,pCvM,pKSF,pCvMF)\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"(A), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"B) KS: p=\" ,round(res[3],4),\", CvM: p=\",round(res[4],4),sep=\"\"),side=3)\n\n\n\n###model 2\n\n\n\n####model 2\n\nfit.X1.qdr=TRUE\n\n\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)] else x<-xo\n\n\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\nif (ind.proc==TRUE) res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nif (ind.proc==FALSE) res.i.c[df$id==gg]<-resP[df$id==gg]- (A+B)%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\nres.i.c2<-resI\n\n\nif (std.type!=1){\nresIS2<-NA\nresIS22<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm22<-matrix(res.i.c2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm22<-V.i%*%resIm22\nresIS22<-c(resIS22,resISm22)\n\n}\n\nresIS2<-resIS2[-1]\nresIS22<-resIS22[-1]\n}\n\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS22[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\nif (individual==FALSE) resP<-resP else resP<-resI\nif (individual==FALSE) estP<-estP else estP<-estI\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(-0.5) else V.i<-V%^%(0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\n\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nif (sign.flip==FALSE) {\n\tif (permute.within==FALSE) smp<-sample(1:(n*N)) else {\n\t\t\t\t\tsmp<-matrix(1:(n*N),ncol=n,byrow=T)\n\t\t\t\t\tsmp<-c(apply(smp,1,sample))\n\t\t\t\t\t}\n\t\t } else {\n\n\tif (flip.cluster==FALSE)\tsmp<-sample(c(-1,1),size=n*N,replace=T) else smp<-rep(sample(c(-1,1),size=N,replace=T),each=n)\n\n\t}\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(0.5) else V.i<-V%^%(-0.5)\n\nif (sign.flip==TRUE){\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute*smp)[df$id==gg]))\n\n} else {\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n}\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nif ( order.by.original==FALSE)  estsI<-fitted(fits,level=1) else estsI<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nif ( order.by.original==FALSE)   estsP<-fitted(fits,level=0) else estsP<-fitted(fit,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs2<-ressI\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\nif (order.by.original==FALSE) {\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-ressP[df$id==gg]- (As+Bs)%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n\n} else {\n\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n\nif (ind.proc==TRUE) {\n\nJ.i<-sigma.est*V.i-A%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n} else {\n\nJ.i<-I-(A+B)%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n}\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-J.i%*%ressI[df$id==gg]\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-J.i%*%ressP[df$id==gg]\n\n}\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-NA\nressIS22<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\n\nresIms22<-matrix(res.i.cs2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms22<-V.i%*%resIms22\nressIS22<-c(ressIS22,resISms22)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS22<-ressIS22[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS22[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\nres<-c(pKS,pCvM,pKSF,pCvMF)\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"(C), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"D) KS: p=\" ,round(res[3],4),\", CvM: p=\",round(res[4],4),sep=\"\"),side=3)\n\n\n####model 3\n\n\nfit.random.effects<-c(1,1)\n\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\nif (ind.proc==TRUE) res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nif (ind.proc==FALSE) res.i.c[df$id==gg]<-resP[df$id==gg]- (A+B)%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\nres.i.c2<-resI\n\n\nif (std.type!=1){\nresIS2<-NA\nresIS22<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm22<-matrix(res.i.c2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm22<-V.i%*%resIm22\nresIS22<-c(resIS22,resISm22)\n\n}\n\nresIS2<-resIS2[-1]\nresIS22<-resIS22[-1]\n}\n\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS22[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\nif (individual==FALSE) resP<-resP else resP<-resI\nif (individual==FALSE) estP<-estP else estP<-estI\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(-0.5) else V.i<-V%^%(0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\n\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nif (sign.flip==FALSE) {\n\tif (permute.within==FALSE) smp<-sample(1:(n*N)) else {\n\t\t\t\t\tsmp<-matrix(1:(n*N),ncol=n,byrow=T)\n\t\t\t\t\tsmp<-c(apply(smp,1,sample))\n\t\t\t\t\t}\n\t\t } else {\n\n\tif (flip.cluster==FALSE)\tsmp<-sample(c(-1,1),size=n*N,replace=T) else smp<-rep(sample(c(-1,1),size=N,replace=T),each=n)\n\n\t}\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nif (individual==FALSE) V.i<-V%^%(0.5) else V.i<-V%^%(-0.5)\n\nif (sign.flip==TRUE){\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute*smp)[df$id==gg]))\n\n} else {\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n}\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nif ( order.by.original==FALSE)  estsI<-fitted(fits,level=1) else estsI<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nif ( order.by.original==FALSE)   estsP<-fitted(fits,level=0) else estsP<-fitted(fit,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs2<-ressI\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\nif (order.by.original==FALSE) {\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-ressP[df$id==gg]- (As+Bs)%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n\n} else {\n\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<-Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n\nif (ind.proc==TRUE) {\n\nJ.i<-sigma.est*V.i-A%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n} else {\n\nJ.i<-I-(A+B)%*%ginv(B)%*%Z%*%D%*%t(Z) %*%V.i\n\n}\n\nif (ind.proc==TRUE) res.i.cs[df$id==gg]<-J.i%*%ressI[df$id==gg]\nif (ind.proc==FALSE) res.i.cs[df$id==gg]<-J.i%*%ressP[df$id==gg]\n\n}\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-NA\nressIS22<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\n\nresIms22<-matrix(res.i.cs2[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms22<-V.i%*%resIms22\nressIS22<-c(ressIS22,resISms22)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS22<-ressIS22[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS22[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\nres<-c(pKS,pCvM,pKSF,pCvMF)\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"(E), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"F) KS: p=\" ,round(res[3],4),\", CvM: p=\",round(res[4],4),sep=\"\"),side=3)\n\ndev.off()\n\n\n\n\n\n######old\n\n\n\n\n\n\n####Yet another last try??\n\n\n####finaly the last last version! note that different residuals are used for O (centered) and F (non-centered) proces\n\n\npdf(\"FiguresimExFinalScaledFinalLastFinalRokfinalNotCenteredDifStat.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\nlibrary(MASS)\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\nxo<-x\n\n\n\n\n####model 1\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\nres.i.c<-resI\n\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nres.i.cs<-ressI\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\n\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\nCvM1<-1/sqrt(n*N)/(mean(WI2)**2)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi1<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(mean(x)**2)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM1<-(sum(CvMi1>=CvM1)+1)/(M+1)\n\n\nCvM2<-1/sqrt(n*N)/(sd(WI2))*sum(cumsum(WI2-mean(WI2))**2)\nCvMi2<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(sd(x))*sum(cumsum(x-mean(x))**2)  ))\n\npCvM2<-(sum(CvMi2>=CvM2)+1)/(M+1)\n\nCvM3<-1/sqrt(n*N)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi3<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM3<-(sum(CvMi3>=CvM3)+1)/(M+1)\n\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"A) T1: p=\" ,round(pCvM1,4),\", T2: p=\" ,round(pCvM2,4),\", T3: p=\" ,round(pCvM3,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"B) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n\n####model 2\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\nres.i.c<-resI\n\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nres.i.cs<-ressI\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\n\nCvM1<-1/sqrt(n*N)/(mean(WI2)**2)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi1<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(mean(x)**2)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM1<-(sum(CvMi1>=CvM1)+1)/(M+1)\n\n\nCvM2<-1/sqrt(n*N)/(sd(WI2))*sum(cumsum(WI2-mean(WI2))**2)\nCvMi2<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(sd(x))*sum(cumsum(x-mean(x))**2)  ))\n\npCvM2<-(sum(CvMi2>=CvM2)+1)/(M+1)\n\nCvM3<-1/sqrt(n*N)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi3<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM3<-(sum(CvMi3>=CvM3)+1)/(M+1)\n\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"C) T1: p=\" ,round(pCvM1,4),\", T2: p=\" ,round(pCvM2,4),\", T3: p=\" ,round(pCvM3,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"D) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n###model 3\n\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\nres.i.c<-resI\n\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nres.i.cs<-ressI\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\n\nCvM1<-1/sqrt(n*N)/(mean(WI2)**2)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi1<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(mean(x)**2)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM1<-(sum(CvMi1>=CvM1)+1)/(M+1)\n\n\nCvM2<-1/sqrt(n*N)/(sd(WI2))*sum(cumsum(WI2-mean(WI2))**2)\nCvMi2<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)/(sd(x))*sum(cumsum(x-mean(x))**2)  ))\n\npCvM2<-(sum(CvMi2>=CvM2)+1)/(M+1)\n\nCvM3<-1/sqrt(n*N)*sum(cumsum(WI2-mean(WI2))**2)\nCvMi3<-unlist(lapply(WsI2,function(x) 1/sqrt(n*N)*sum(cumsum(x-mean(x))**2)  ))\n\npCvM3<-(sum(CvMi3>=CvM3)+1)/(M+1)\n\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"D) T1: p=\" ,round(pCvM1,4),\", T2: p=\" ,round(pCvM2,4),\", T3: p=\" ,round(pCvM3,4),sep=\"\"),side=3)\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"F) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n###########################\n\n\n\n####Yet another last try??\n\n\n####finaly the last last version! note that different residuals are used for O (centered) and F (non-centered) proces\n\n\npdf(\"FiguresimExFinalScaledFinalLastFinalRokfinalTheOtherDef.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\nlibrary(MASS)\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\nxo<-x\n\n\n\n\n####model 1\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\n\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estP\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-A%*%estP[df$id==gg]\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n#orsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsP\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-As%*%estsP[df$id==gg]\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-0.7,0.7),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"A) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"B) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n\n####model 2\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estP\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-A%*%estP[df$id==gg]\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsP\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-As%*%estsP[df$id==gg]\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-0.7,0.7),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"C) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"D) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n###model 3\n\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estP\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-A%*%estP[df$id==gg]\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsP\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-As%*%estsP[df$id==gg]\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-1,1),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"E) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"F) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n########################\n\n####old\n\n\n\n\n\n\n\n\n####finaly the last last version! note that different residuals are used for O (centered) and F (non-centered) proces\n\n\npdf(\"FiguresimExFinalScaledFinalLastFinalRokfinal.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\nlibrary(MASS)\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\nxo<-x\n\n\n\n\n####model 1\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\n\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-B%*%estI[df$id==gg]-A%*% ginv(B)%*%matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-Bs%*%estsI[df$id==gg]-As%*% ginv(Bs)%*%matrix(estsI[df$id==gg]- x[df$id==gg,]%*%beta.fs ,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-0.5,0.5),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"A) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"B) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n\n####model 2\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-B%*%estI[df$id==gg]-A%*% ginv(B)%*%matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-Bs%*%estsI[df$id==gg]-As%*% ginv(Bs)%*%matrix(estsI[df$id==gg]- x[df$id==gg,]%*%beta.fs ,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-0.5,0.5),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"C) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"D) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n###model 3\n\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nest.i.c<-estI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\nest.i.c[df$id==gg]<-B%*%estI[df$id==gg]-A%*% ginv(B)%*%matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\norI<-order(est.i.c)\nresoI2<-resIS2[orI]\n\nt01<- est.i.c\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nest.i.cs<-estsI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\nest.i.cs[df$id==gg]<-Bs%*%estsI[df$id==gg]-As%*% ginv(Bs)%*%matrix(estsI[df$id==gg]- x[df$id==gg,]%*%beta.fs ,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\norsI<-order(est.i.cs)\nresosI2<-ressIS2[orsI]\n\nt01s<- est.i.cs\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-0.5,0.5),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"E) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"F) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n################################\n################################\n\n\n####old\n\n\n\n####finaly the last last version! note that different residuals are used for O (centered) and F (non-centered) proces\n\n\npdf(\"FiguresimExFinalScaledFinalLastFinal.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\nlibrary(MASS)\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\nxo<-x\n\n\n\n\n####model 1\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)]\n\n\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"A) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"B) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n\n####model 2\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"C) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"D) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n\n###model 3\n\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\n\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (sim.X1.qdr==TRUE) if (fit.X1.qdr==FALSE) x<-xo[,-ncol(x)] else x<-xo\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\nbeta.f<-fixef(fit)\nres.i.c<-resI\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\n\n\nA<-sigma.est*V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n#B<-x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,])+ Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\nB<- Z%*%D%*%t(Z) %*%V.i%*%( V- x[df$id==gg,]%*%H.i%*%t(x[df$id==gg,]) )%*%V.i%*%Z%*%D%*%t(Z)\n\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]  ,ncol=1)\n#res.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta ,ncol=1)\nres.i.c[df$id==gg]<-resI[df$id==gg]- A%*%ginv(B)%*% matrix(estI[df$id==gg]- x[df$id==gg,]%*%beta.f ,ncol=1)\n\n\n\n}\n\n\nif (std.type!=1){\nresIS2<-resIS<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(res.i.c[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.i%*%resIm\nresIS<-c(resIS,resISm)\n\n}\n\nresIS2<-resIS2[-1]\nresIS<-resIS[-1]\n\n}\n\n\nresoI2<-resIS2[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n#plot(1:(n*N),WI2,type=\"l\")\n\nresoP2<-resIS[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\n\nHs<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n\n\nbeta.fs<-fixef(fits)\nres.i.cs<-ressI\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\n\n\nAs<-sigma.ests*V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n#Bs<-x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,])+ Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\nBs<- Z%*%Ds%*%t(Z) %*%V.is%*%( Vs- x[df$id==gg,]%*%H.is%*%t(x[df$id==gg,]) )%*%V.is%*%Z%*%Ds%*%t(Z)\n\nres.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta.fs,ncol=1)\n#res.i.cs[df$id==gg]<-ressI[df$id==gg]- As%*%ginv(Bs)%*% matrix(estsI[df$id==gg]-x[df$id==gg,]%*%beta,ncol=1)\n\n\n}\n\n\n\n\n\n\nif (std.type!=1){\n ressIS2<-ressIS<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(res.i.cs[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.i%*%resIms\nressIS<-c(ressIS,resISms)\n\n}\n\nressIS2<-ressIS2[-1]\nressIS<-ressIS[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\n\n\n\nKS<-max(abs(WI2))\nCvM<-sum(WI2**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\n\nKSi<-unlist(lapply(WsI2,function(x) max(abs(x)) ))\nCvMi<-unlist(lapply(WsI2,function(x) sum(x**2) ))\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(1:(n*N),WI2,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=expression(W^O),xlab=\"\")\nfor (ii  in 1:M){\nlines(1:(n*N),WsI2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(1:(n*N),WI2,type=\"s\" )\n\nmtext(paste(\"E) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\n\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),ylab=expression(W^F),xlab=\"\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\n\nmtext(paste(\"F) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n###################old\n\n###maybe now?\n\n\npdf(\"FiguresimExFinalScaledFinal.pdf\",height=10,width=10)\n\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n scale.to.unit.variance=FALSE\n\n\n####model 1\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS2[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS2[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(round(to1o,10),dif,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=\"W^O\",xlab=\"\")\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\nmtext(paste(\"A) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=\"W^F\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\nmtext(paste(\"B) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n####model 2\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS2[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS2[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(round(to1o,10),dif,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=\"W^O\",xlab=\"\")\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\nmtext(paste(\"C) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=\"W^F\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\nmtext(paste(\"D) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\n\n####model 3\nfit.X1.qdr=TRUE\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\nresoI2<-resIS2[orI]\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\nresoP2<-resIS2[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\n\n\nrespermute<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\nresPMp<-matrix(resP[df$id==gg],ncol=1,nrow=n,byrow=F)\nresPMp2<-V.i%*%resPMp\nrespermute<-c(respermute,resPMp2)\n}\n\nrespermute<-respermute[-1]\n\nWsP2<-WsI2<-estYs01<-list()\nfor (ii in 1:M){\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estP[df$id==gg]+  V.i%*%( (respermute[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nt01s<- estsI\n\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\nresosP2<-ressIS2[orsP]\n\n\nt01Ps<- estsP\nfor (zz in as.numeric(names(table(t01Ps[orsP]))[which(table(t01Ps[orsP])>1)])){\nigsP<-which(round(t01Ps[orsP],10)==round(zz,10))\nresosP2[igsP]<-sum(resosP2[igsP])/length(igsP)\n}\n\n\nWsP2[[ii]]<-1/sqrt(N*n)*cumsum(resosP2)\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n\n\nKSiP<-unlist(lapply(WsP2,function(x) max(abs(x)) ))\nCvMiP<-unlist(lapply(WsP2,function(x) sum(x**2) ))\nKSP<-max(abs(WP2))\nCvMP<-sum(WP2**2)\n\npKSF<-(sum(KSiP>=KSP)+1)/(M+1)\npCvMF<-(sum(CvMiP>=CvMP)+1)/(M+1)\n\n\n\n\nplot(round(to1o,10),dif,col=\"red\",type=\"s\",ylim=c(-2,2),ylab=\"W^O\",xlab=\"\")\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\nmtext(paste(\"E) KS: p=\" ,round(pKS,4),\", CvM: p=\",round(pCvM,4),sep=\"\"),side=3)\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=\"W^F\")\nfor (ii in 1:M){\nlines(1:(n*N),WsP2[[ii]],type=\"s\",col=\"lightgray\")\n}\nlines(1:(n*N),WP2,type=\"s\")\n\nmtext(paste(\"F) KS: p=\" ,round(pKSF,4),\", CvM: p=\",round(pCvMF,4),sep=\"\"),side=3)\n\n\n\ndev.off()\n\n\n\n\n\n\n\n\n\n############################\n############################\n\n###maybe now?\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nresI<-residuals(fit, level = 1  )\n\n\n\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\n\n\nresIS2<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n\n\norP<-order(estP)\n\n\nresoP2<-resIS2[orP]\n\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\nKSP<-max(abs(WP2))\nCVMP<-sum(WP2**2)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\n\nWPs<-matrix(NA,ncol=n*N,nrow=M)\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\n\nplot(1:(n*N),unlist(WI2i),type=\"s\",ylim=c(-3,3))\nfor (ii in 1:M){\n\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estI[df$id==gg]+  V.i%*%( (resIS2[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\nressI<-residuals(fits,level=1)\n\n\n\n estsP<-fitted(fits,level=0)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.ests*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n\nWPs[ii,]<-1/sqrt(n*N)*cumsum( ressIS2[order(estsP)] )\n lines(1:(n*N),WPs[ii,],col=\"lightgray\")\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(n*N),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n\n}\nlines(1:(n*N),unlist(WI2i),type=\"s\")\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1))\nfor (ii in 1:M){\nlines(1:(n*N),WPs[ii,],type=\"s\",col=\"lightgray\")\n}\n\nlines(1:(N*n),WP2,type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\nKSps<-apply(WPs,1,function(x) max(abs(x)) )\nCVMps<-apply(WPs,1,function(x) sum(x**2) )\n\n\npKSP<-(sum(KSps>=KSP)+1)/(M+1)\npCVMP<-(sum(CVMps>=CVMP)+1)/(M+1)\n\n\n\n\nres<-c(pKS,pCvM,pKSP,pCVMP)\n\n\n###model 2\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nresI<-residuals(fit, level = 1  )\n\n\n\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\n\n\nresIS2<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n\n\norP<-order(estP)\n\n\nresoP2<-resIS2[orP]\n\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\nKSP<-max(abs(WP2))\nCVMP<-sum(WP2**2)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\n\nWPs<-matrix(NA,ncol=n*N,nrow=M)\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\n\nplot(1:(n*N),unlist(WI2i),type=\"s\",ylim=c(-3,3))\nfor (ii in 1:M){\n\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estI[df$id==gg]+  V.i%*%( (resIS2[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\nressI<-residuals(fits,level=1)\n\n\n\n estsP<-fitted(fits,level=0)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.ests*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n\nWPs[ii,]<-1/sqrt(n*N)*cumsum( ressIS2[order(estsP)] )\n lines(1:(n*N),WPs[ii,],col=\"lightgray\")\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(n*N),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n\n}\nlines(1:(n*N),unlist(WI2i),type=\"s\")\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1))\nfor (ii in 1:M){\nlines(1:(n*N),WPs[ii,],type=\"s\",col=\"lightgray\")\n}\n\nlines(1:(N*n),WP2,type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\nKSps<-apply(WPs,1,function(x) max(abs(x)) )\nCVMps<-apply(WPs,1,function(x) sum(x**2) )\n\n\npKSP<-(sum(KSps>=KSP)+1)/(M+1)\npCVMP<-(sum(CVMps>=CVMP)+1)/(M+1)\n\n\n\n\nres<-c(pKS,pCvM,pKSP,pCVMP)\n\n\n\n###model 3\n\nfit.random.effects<-c(1,1)\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nresI<-residuals(fit, level = 1  )\n\n\n\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\n\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n\n\n\nresIS2<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n\n\norP<-order(estP)\n\n\nresoP2<-resIS2[orP]\n\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\nKSP<-max(abs(WP2))\nCVMP<-sum(WP2**2)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\n\nWPs<-matrix(NA,ncol=n*N,nrow=M)\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\n\nplot(1:(n*N),unlist(WI2i),type=\"s\",ylim=c(-3,3))\nfor (ii in 1:M){\n\n\nsmp<-sample(1:(n*N)) #reshufle everything\n\nys<-NA\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(0.5)\n\nys<-c(ys,estI[df$id==gg]+  V.i%*%( (resIS2[smp])[df$id==gg]))\n\n\n}\nys<-ys[-1]\n\n\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\nressI<-residuals(fits,level=1)\n\n\n\n estsP<-fitted(fits,level=0)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n\n#V.i<-V%^%(-0.5)\n G.i<- sigma.ests*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n\nWPs[ii,]<-1/sqrt(n*N)*cumsum( ressIS2[order(estsP)] )\n lines(1:(n*N),WPs[ii,],col=\"lightgray\")\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(n*N),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n\n}\nlines(1:(n*N),unlist(WI2i),type=\"s\")\n\nplot(1:(n*N),WP2,type=\"s\",ylim=c(-1,1))\nfor (ii in 1:M){\nlines(1:(n*N),WPs[ii,],type=\"s\",col=\"lightgray\")\n}\n\nlines(1:(N*n),WP2,type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\nKSps<-apply(WPs,1,function(x) max(abs(x)) )\nCVMps<-apply(WPs,1,function(x) sum(x**2) )\n\n\npKSP<-(sum(KSps>=KSP)+1)/(M+1)\npCVMP<-(sum(CVMps>=CVMP)+1)/(M+1)\n\n\n\n\nres<-c(pKS,pCvM,pKSP,pCVMP)\n\n\nres\n\n\n\n\n\n\n\n##################\n\n\n### will this be the final version? :)\n\npdf(\"FiguresimExF2F2.pdf\",height=10,width=10)\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(A), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-2,2),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(B), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(C), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-2,2),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(D), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n\n####model 3\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(E), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-2,2),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<- apply(smp,1,sample)\n#smp<- c(smp)\nsmp<-c(smp[,sample(1:N)])\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-chol(V)\nV.i=solve(t(V.i))\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(F), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n#####################\n\n\n### will this be the final version? :), no it will not be!\n\npdf(\"FiguresimExF2.pdf\",height=10,width=10)\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(A), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(B), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(C), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(D), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n\n####model 3\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\nKS<-max(KSi)\nKSs<-apply(KSis,2,max)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-sum(CvMi)\nCvMs<-apply(CvMis,2,sum)\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(E), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\nKS<-c(KSi)\nKSs<-c(KSis)\n\npKS<-(sum(KSs>=KS)+1)/(M+1)\n\nCvM<-c(CvMi)\nCvMs<-c(CvMis )\n\npCvM<-(sum(CvMs>=CvM)+1)/(M+1)\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(F), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\ndev.off()\n\n\n\n\n###\n\n\n####the usual plots\n\npdf(\"FiguresimEx2F.pdf\",height=4,width=9)\n\n\nset.seed(10)\npar(mfrow=c(1,3),mar=c(4,5,3,1))\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\n\n\n#plot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nplot(est,resIS2,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nabline(h=0)\nmtext(\"(A)\",side=3,cex=1.2, line=0.5)\n\n\n########\n\nfit.X1.qdr=TRUE\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\n#plot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nplot(est,resIS2,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\n\nabline(h=0)\nmtext(\"(B)\",side=3,cex=1.2, line=0.5)\n\n\n\n########\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\n vc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\n#plot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nplot(est,resIS2,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nabline(h=0)\nmtext(\"(C)\",side=3,cex=1.2, line=0.5)\n\n\ndev.off()\n\n\n\n\n\n\n\n\n\n\n\n\n\n##old\n\n\n####################\n\n\n\n\n### will this be the final version?, Jakob ps :) not good at all!\n\npdf(\"FiguresimExF21.pdf\",height=10,width=10)\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\nihCDF = function(x, n) {\n  xf = floor(x)\n  sum(vapply(0:xf, function(k)  choose(n, k) * (-1)^k * (x - k)^n, FUN.VALUE = 0)) / factorial(n) }\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\nfit.random.effects<-c(1,0)\n\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#if (fit.X1.qdr==FALSE) x<-x[,-ncol(x)]\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\n\npCvM<- ihCDF(tc,N)\npKS<-max(pik)**N\npCvM<-max(pic)**N\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(A), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\n\npCvM<- ihCDF(tc,N)\n\n pKS<-max(pik)**N\npCvM<-max(pic)**N\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(B), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\n\npCvM<- ihCDF(tc,N)\n\n pKS<-max(pik)**N\npCvM<-max(pic)**N\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(C), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\n\npCvM<- ihCDF(tc,N)\n\npKS<-max(pik)**N\npCvM<-max(pic)**N\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(D), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n\n####model 3\n\n#####model 2, O proc\n\nfit.X1.qdr=TRUE\nfit.random.effects<-c(1,1)\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-list()\n\nfor (gg in 1:N){\nWI2i[[gg]]<-1/sqrt(n)*cumsum(resIS2[df$id==gg][order(estP[df$id==gg])])\n}\n\n\n\nKSi<-unlist(lapply( WI2i,function(x) max(abs(x) )))\nCvMi<-unlist(lapply( WI2i,function(x) sum(x**2) ))\n\ntxt1<-expression(W )\n\nplot(1:(N*n),unlist(WI2i),type=\"s\",ylim=c(-3,3),xlab=\"\",ylab=txt1,axes=F)\naxis(2)\naxis(1,at=seq(from=1,by=n,length.out=N),label=rep(1:N))\nbox()\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=N,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<-list()\n\nfor (gg in 1:N){\nWI2is[[gg]]<-1/sqrt(n)*cumsum(ressIS2[df$id==gg][order(estsP[df$id==gg])])\n}\n\nlines(1:(N*n),unlist(WI2is),type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-unlist(lapply( WI2is,function(x) max(abs(x) )))\nCvMis[,ii]<-unlist(lapply( WI2is,function(x) sum(x**2) ))\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n),unlist(WI2i),type=\"s\")\n\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\npCvM<- ihCDF(tc,N)\n\npKS<-max(pik)**N\npCvM<-max(pic)**N\n\n\n\nres <-c(pKS,pCvM)\n\n\nmtext(paste(\"(E), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\n####F proces\n\nstd.type=2\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\n orI<-order(estP)\n\nWI2i<-1/sqrt(n*N)*cumsum(resIS2[order(estP)])\n\n\n\n\n\nKSi<-  max(abs(WI2i) )\nCvMi<- sum(WI2i**2)\n\ntxt1<-expression(W^F)\n\nplot(1:(N*n), WI2i ,type=\"s\",ylim=c(-1,1),xlab=\"\",ylab=txt1)\n\n\n\n\n\nCvMis<-KSis<-matrix(NA,nrow=1,ncol=M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\n#ys<-estP+resP[smp]\n#ys<-estI+resP[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\n orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\nWI2is<- 1/sqrt(n*N)*cumsum(ressIS2[order(estsP)])\n\n\nlines(1:(N*n), WI2is ,type=\"s\",col=\"lightgray\")\n\nKSis[,ii]<-  max(abs(WI2is) )\nCvMis[,ii]<- sum(WI2is**2)\n\n\n#WsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n#estYs01[[ii]]<-t01s[orsI]\n\n\n}\n\nlines(1:(N*n), WI2i ,type=\"s\")\n\n\npik<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , KSis,KSi ))\npic<-unlist( lapply(1:N,function( i,x,y  )  (sum(x[i,]>=y[i])+1)/(M+1) , CvMis,CvMi ))\n\ntk<-sum(pik)\ntc<-sum(pic)\n\npKS<- ihCDF(tk,N)\n\n\npCvM<- ihCDF(tc,N)\n\n\n\nres <-c(pKS,pCvM)\n\nmtext(paste(\"(F), KS p=\",round(res[1],4),\", CvM p=\",round(res[2],4),sep=\"\"),side=3)\n\n\n\ndev.off()\n\n\n\n\n###\n\n\n\n\n\n####old\n\n\n####Figure for illustration, final\n\npdf(\"FiguresimExF.pdf\",height=10,width=10)\n\nset.seed(10)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\n\n\n\n\nlibrary(nlme)\nlibrary(mvtnorm)\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nN=50\nn=25\np=1\nbetafe=c(-1,0.25)\nvar.fe=0.25\n\nsim.random.effects<-c(1,1) #which RE do you want to simulate, has to be the length p+1\n#Dsim<-rbind(c(0.25,0,0),c(0,0.25,0),c(0,0,2)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\nDsim<-rbind(c(0.25,0),c(0,1)) #RE D matrix, should be dim sum(sim.random.effects) x sum(sim.random.effects)\n\n\nM=250\n\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X (of the first covariate), but fit the model with a linear effect only\nbb=0.5 #coefficient for the qudratic effect\n\nfit.X1.qdr=FALSE\n\n\nstd.type=2#  c(1,2,3) #1 - pearson, 2 - V, 3 - GvG\nfit.diagonal=TRUE #fit LMM with diagonal D\n\nproc.F=FALSE #if true it looks at F proces, looks at O otherwise\nscale.to.unit.variance=FALSE\n\n######sim data\n\nif (sim.X1.qdr==TRUE) beta<-c(betafe,bb)  else beta<-betafe\n\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,1]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nZi<-x[id==ii,which(sim.random.effects==1) ]\n\nre<-matrix(rmvnorm(1,rep(0,nrow(Dsim)),Dsim),ncol=1)\n\n\ny<-c(y,x[id==ii,]%*%beta+Zi%*%re+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n########end sim data\n#fit lin and int RE only, plot O\n\nfit.random.effects<-c(1,0,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=FALSE\nproc.F=FALSE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(A) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^O)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-2,2),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\n\n\n####\n\n#fit lin and int RE only, plot F\n\nfit.random.effects<-c(1,0,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=FALSE\nproc.F=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(B) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^F)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-1,1),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\n\n\n\n####\n\n#fit qdr and int RE only, plot O\n\nfit.random.effects<-c(1,0,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=TRUE\nproc.F=FALSE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(C) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^O)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-2,2),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\n\n\n####\n\n#fit qdr and int RE only, plot O\n\nfit.random.effects<-c(1,0,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=TRUE\nproc.F=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(D) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^F)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-1,1),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\n\n\n\n\n\n\n####\n\n#fit qdr and int RE only, plot O\n\nfit.random.effects<-c(1,1,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=TRUE\nproc.F=FALSE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(E) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^O)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-1,1),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\n\n####\n\n#fit qdr and int RE only, plot O\n\nfit.random.effects<-c(1,1,0) #which RE do you want to fit set to sim.random.effects if the correct RE is fitted\nfit.X1.qdr=TRUE\nproc.F=TRUE\n\n\n#fit.model\nif (fit.X1.qdr==FALSE) {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n} else {\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n}\n\nif (sum(fit.random.effects)>1) {\nre<-as.formula(paste(\"~\",paste(((names(df)[1:(p+1)])[which(fit.random.effects==1)])[-1],collapse=\"+\"),sep=\"\"))\n  } else {\nre<-as.formula(\"~1\")\n\n}\n\n\nif (fit.diagonal==TRUE){\nfit<-lme(fixed=form, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )   } else {\nfit<-lme(fixed=form, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\nif (std.type==1) resIS2<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\nI<-diag(rep(1,n))\n\nif (std.type==3){\nH<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\nif (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.i<-V%^%(-1)\nH<-H+t(x[df$id==gg,])%*%V.i%*%x[df$id==gg,]\n}\n\nH.i<-solve(H)\n}\n\nif (std.type!=1){\nresIS2<-NA\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nif (std.type==2){\nV.i<-V%^%(-0.5)\n}\nif (std.type==3){\nG.i<- sigma.est*V%^%(-1)\nvar.est<-G.i%*%( V-x[df$id==gg,]%*%H.i %*%t(x[df$id==gg,]))%*%G.i\nV.i<-var.est%^%(-0.5)\n}\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\n}\n\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\nif (proc.F==FALSE) orI<-order(estI) else orI<-order(estP)\n\nresoI2<-resIS2[orI]\nif (proc.F==FALSE)  t01<- estI else t01<- estP\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\n\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\n\nWsI2<-estYs01<-list()\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nif (fit.diagonal==TRUE){\nfits<-lme(fixed=forms, data=df, random=list(id=pdDiag(re)),control=lmeControl( returnObject = TRUE),method=\"REML\" )  } else {\nfits<-lme(fixed=forms, data=df, random=list(id=re),control=lmeControl( returnObject = TRUE),method=\"REML\" )\n}\n\nif (std.type==1) ressIS2<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\n estsP<-fitted(fits,level=0)\nif (proc.F==FALSE)  orsI<-order(estsI) else orsI<-order(estsP)\n\n\n\n\nvcs<-VarCorr(fits)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n\nDs<-getVarCov(fits)\n\n\nif (std.type==3){\nHs<-matrix(0,ncol=p+1,nrow=p+1)\nfor (gg in 1:N){\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.is<-Vs%^%(-1)\nHs<-Hs+t(x[df$id==gg,])%*%V.is%*%x[df$id==gg,]\n}\n\nH.is<-solve(Hs)\n}\n\nif (std.type!=1){\n ressIS2<-NA\nfor (gg in 1:N){\n\n if (nrow(vc)>2) Z<-x[df$id==gg,which(fit.random.effects==1)] else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n if (std.type==2){\nV.i<-V%^%(-0.5)\n}\n if (std.type==3){\nG.is<- sigma.ests*V%^%(-1)\nvar.ests<-G.is%*%( V-x[df$id==gg,]%*%H.is %*%t(x[df$id==gg,]))%*%G.is\nV.i<-var.ests%^%(-0.5)\n}\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n }\n\nresosI2<-ressIS2[orsI]\n\nif (proc.F==FALSE)  t01s<- estsI else t01s<- estsP\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\n}\n\n\n\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\nestYs01[[ii]]<-t01s[orsI]\n\n\n}\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01),10))\nuniqt<-uniqt[order(uniqt)]\nestYs01r<-lapply(estYs01,function(x) round(x,10))\nst<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) }, estYs01r ,WsI2 )\n\n\nstepfs<-lapply(1:M,function(i,x, z) {x[[i]](z)},st ,uniqt)\n\nmm<-matrix(unlist(stepfs),nrow=M,byrow=T)\nmns<-colMeans(mm)\n\nmns.step<-stepfun( uniqt,c(0,mns) )\n\nif (scale.to.unit.variance==TRUE){\nmnsm<-matrix(mns,ncol=ncol(mm),nrow=nrow(mm),byrow=T)\nsds<-sqrt(colMeans((mm-mnsm)**2))\nsds.step<-stepfun( uniqt,c(0,sds) )\n}\n\n\n##dif needed for test stat\nto1o<-round(t01[orI],10)\n\n#dif<-unlist(lapply(1:length(WI2),function(i,x,y,z,g)  x[i]- g[which(z<=(y[i]))[sum(z<=(y[i]))]],WI2,to1o,uniqt,mns  ))\n\nstI2<-stepfun(to1o,c(0,WI2))\n\n\n\ndif<-stI2(to1o)- mns.step(to1o)\nif (scale.to.unit.variance==TRUE){\ndif<-dif/sds.step(to1o)\n}\n\n\nKS<-max(abs(dif))\nCvM<-sum(dif**2)\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\nif (scale.to.unit.variance==FALSE){ difs[,ii]<-st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]) } else {difs[,ii]<-(st[[ii]](estYs01r[[ii]])-mns.step(estYs01r[[ii]]))/sds.step(estYs01r[[ii]])}\n}\nKSi<-apply(difs,2,function(x) max(abs(x)) )\nCvMi<-apply(difs,2,function(x) sum(x**2) )\n\npKS<-(sum(KSi>=KS)+1)/(M+1)\npCvM<-(sum(CvMi>=CvM)+1)/(M+1)\n c(pKS,pCvM)\n\nman<-paste(\"(F) \",\"p=\",round(pCvM,4),sep=\"\")\ntxt<-expression(W^F)\n\nplot(round(to1o,10),dif, type=\"s\",ylim=c(-1,1),main=man,xlab=\"\",ylab=txt)\nfor (ii  in 1:M){\nlines(estYs01r[[ii]],difs[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(round(to1o,10),dif,type=\"s\" )\n\ndev.off()\n\n\n\n\n\n\n\n######################################################\n############old\n\n####Figure for illustration\n set.seed(1)\nlibrary(nlme)\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nN=100\nn=50\np=2\nbeta=c(-1,0.25,0.1)\nvar.fe=0.5\nvar.re1<-0.25\nvar.re2<-1\n\nB=1000\nM=250\nfit.correct.RE=TRUE\nsim.X1.qdr=TRUE #will simulate a quadratic effect of X, but fit the model with a linear effect only\nbb=-1 #coefficient for the qudratic effect\n\n\n\nif (sim.X1.qdr==TRUE) beta<-c(beta,bb)\n\n#sim.data\n\nx<-matrix(runif(N*n*p),ncol=p)\nif (sim.X1.qdr==FALSE) x<-cbind(1,x) else x<-cbind(1,x,x[,2]**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\n\nbetar<-c(beta[1]+re,beta[2]+re2, beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n#fit.model 1\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\nform.re<-as.formula(\"~X2|id\")\n form.re<-as.formula(\"~1|id\")\n\n\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE,opt=\"nlminb\") ,method=\"ML\")\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\nresP<-residuals(fit, level = 0  )\n\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\nif (nrow(vc)>2) est.re2<-as.numeric(vc[2,1])\nif (nrow(vc)>2) cov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\nif (nrow(vc)>2) D<-rbind(c(est.re1,cov.re),c(cov.re,est.re2)) else D<-est.re1\nI<-diag(rep(1,n))\n\n resIS2<-NA\nfor (gg in 1:N){\n\nif (nrow(vc)>2) Z<-cbind(1,x[df$id==gg,2]) else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\n\nV.i<-V%^%(-0.5)\n\n\nresIm2<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm2<-V.i%*%resIm2\nresIS2<-c(resIS2,resISm2)\n\n\n}\n\nresIS2<-resIS2[-1]\n\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estI-estP)\n\nresoI2<-resIS2[orI]\nresoI<-resIS[orI]\nt01<- estI\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\nresoI[ig]<-sum(resoI[ig])/length(ig)\n}\n\n\n\nWI2<-1/sqrt(N*n)*cumsum(resoI2)\n\n\n\nresoP2<-resIS2[orP]\n\nWP2<-1/sqrt(N*n)*cumsum(resoP2)\n\ntP.KS2<-max(abs(WP2))\ntP.CvM2<-sum(WP2**2)\n\n\nresoR2<-resIS2[orR]\nresoR<-resIS[orR]\nt01r<- estI-estP\nfor (ii in as.numeric(names(table(t01r[orR]))[which(table(t01r[orR])>1)])){\nigr<-which(round(t01r[orR],10)==round(ii,10))\nresoR2[igr]<-sum(resoR2[igr])/length(igr)\nresoR[igr]<-sum(resoR[igr])/length(igr)\n}\n\nWR2<-1/sqrt(N*n)*cumsum(resoR2)\n\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\n\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\n\n\nt01O<-  estI\nt01R<-  estI-estP\n\n\n\ntsP.KS2<-tsP.CvM2<-tsP.KS<-tsP.CvM <-rep(NA,M)\n\nWsI2<-WsI<-WsR2<-WsR<-estYs01O<-estYs01R<-list()\nWsPi<-WsPi2<-list()\nestYiP<-list()\n\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE,opt=\"nlminb\") ,method=\"ML\")\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nressP<-residuals(fits,level=0)\n\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsI-estsP)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\nif (nrow(vcs)>2) est.re2s<-as.numeric(vcs[2,1])\nif (nrow(vcs)>2) cov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\nif (nrow(vcs)>2) Ds<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s)) else Ds<-est.re1s\n\n ressIS2<-NA\nfor (gg in 1:N){\n\nif (nrow(vcs)>2) Z<-cbind(1,x[df$id==gg,2]) else Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%Ds%*%t(Z)+sigma.ests*I\n\nV.i<-V%^%(-0.5)\n\n\n\nresIms2<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms2<-V.i%*%resIms2\nressIS2<-c(ressIS2,resISms2)\n}\n\nressIS2<-ressIS2[-1]\n\n\n\n\nt01Rs<- estsI-estsP\nt01Os<- estsI\nt01Ps<- estsP\nestYs01O[[ii]]<-t01Os[orsI]\nestYs01R[[ii]]<-t01Rs[orsR]\nestYiP[[ii]]<-t01Ps[orsP]\nresosI2<-ressIS2[orsI]\nresosI<-ressIS[orsI]\nt01s<- estsI\nfor (zz in as.numeric(names(table(t01s[orsI]))[which(table(t01s[orsI])>1)])){\nigs<-which(round(t01s[orsI],10)==round(zz,10))\nresosI2[igs]<-sum(resosI2[igs])/length(igs)\nresosI[igs]<-sum(resosI[igs])/length(igs)\n}\nWsI2[[ii]]<-1/sqrt(N*n)*cumsum(resosI2)\n\n\n\n\nresosP2<-ressIS2[orsP]\nWsP2<-1/sqrt(N*n)*cumsum(resosP2)\ntsP.KS2[ii]<-max(abs(WsP2))\ntsP.CvM2[ii]<-sum(WsP2**2)\nWsPi2[[ii]]<-WsP2\n\nresosR2<-ressIS2[orsR]\nresosR<-ressIS[orsR]\nt01rs<- estsI-estsP\nfor (zz in as.numeric(names(table(t01rs[orsR]))[which(table(t01rs[orsR])>1)])){\nigrs<-which(round(t01rs[orsR],10)==round(zz,10))\nresosR2[igrs]<-sum(resosR2[igrs])/length(igrs)\nresosR[igrs]<-sum(resosR[igrs])/length(igrs)\n}\n\n\nWsR2[[ii]]<-1/sqrt(N*n)*cumsum(resosR2)\n\n\nWsI[[ii]]<-1/sqrt(N*n)*cumsum(resosI)\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n WsPi[[ii]]<-WsP\nWsR[[ii]]<-1/sqrt(N*n)*cumsum(resosR)\n\n}\n\n\npvP.KS2<- (sum(tsP.KS2>=tP.KS2)+1)/(M+1)\npvP.CvM2<- (sum(tsP.CvM2>=tP.CvM2)+1)/(M+1)\n\n pvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\n\n###scale to zero mean\nuniqt<-unique(round(unlist(estYs01O),10))\nuniqt<-uniqt[order(uniqt)]\n\nestYs01Or<-lapply(estYs01O,function(x) round(x,10))\n\nst1<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) },estYs01Or,WsI )\nst2<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) },estYs01Or,WsI2 )\n\n\nstepfs1<-lapply(1:M,function(i,x, z) {x[[i]](z)},st1 ,uniqt)\nstepfs2<-lapply(1:M,function(i,x, z) {x[[i]](z)},st2 ,uniqt)\n\nmm1<-matrix(unlist(stepfs1),nrow=M,byrow=T)\nmns1<-colMeans(mm1)\n\n\nmns.step1<-stepfun( uniqt,c(0,mns1) )\n\nmm2<-matrix(unlist(stepfs2),nrow=M,byrow=T)\nmns2<-colMeans(mm2)\n\n\nmns.step2<-stepfun( uniqt,c(0,mns2) )\n\n\n##dif needed for test stat\nto1o<-round(t01O[orI],10)\nstI2<-stepfun(to1o,c(0,WI2))\nstI1<-stepfun(to1o,c(0,WI))\n\n\ndif2<-stI2(to1o)- mns.step2(to1o)\n\nKSO2<-max(abs(dif2))\nCvMO2<-sum(dif2**2)\n\n\ndif1<-stI1(to1o)- mns.step1(to1o)\n\nKSO1<-max(abs(dif1))\nCvMO1<-sum(dif1**2)\n\n\n#lines(to1o,dif,col=\"red\",type=\"s\")\n\n\ndifs2<-matrix(NA,ncol=length(WsI2),nrow=N*n)\nfor (ii in 1:length(WsI2)){\ndifs2[,ii]<-st2[[ii]](estYs01Or[[ii]])-mns.step2(estYs01Or[[ii]])\n}\nKSi2<-apply(difs2,2,function(x) max(abs(x)) )\nCvMi2<-apply(difs2,2,function(x) sum(x**2) )\n\ndifs1<-matrix(NA,ncol=length(WsI),nrow=N*n)\nfor (ii in 1:length(WsI)){\ndifs1[,ii]<-st1[[ii]](estYs01Or[[ii]])-mns.step1(estYs01Or[[ii]])\n}\nKSi1<-apply(difs1,2,function(x) max(abs(x)) )\nCvMi1<-apply(difs1,2,function(x) sum(x**2) )\n\n\npKSO1<-(sum(KSi1>=KSO1)+1)/(M+1)\npCvMO1<-(sum(CvMi1>=CvMO1)+1)/(M+1)\n\npKSO2<-(sum(KSi2>=KSO2)+1)/(M+1)\npCvMO2<-(sum(CvMi2>=CvMO2)+1)/(M+1)\n\n####\n\n###scale to zero mean\nuniqtR<-unique(round(unlist(estYs01R),10))\nuniqtR<-uniqtR[order(uniqtR)]\nestYs01Rr<-lapply(estYs01R,function(x) round(x,10))\n\nst1R<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) },estYs01Rr,WsR )\nst2R<-lapply(1:M,function(i,x,y) { stepfun( x[[i]],c(0,y[[i]]) ) },estYs01Rr,WsR2 )\n\n\nstepfs1R<-lapply(1:M,function(i,x, z) {x[[i]](z)},st1R ,uniqtR)\nstepfs2R<-lapply(1:M,function(i,x, z) {x[[i]](z)},st2R ,uniqtR)\n\nmm1R<-matrix(unlist(stepfs1R),nrow=M,byrow=T)\nmns1R<-colMeans(mm1R)\n\n\nmns.step1R<-stepfun( uniqtR,c(0,mns1R) )\n\nmm2R<-matrix(unlist(stepfs2R),nrow=M,byrow=T)\nmns2R<-colMeans(mm2R)\n\n\nmns.step2R<-stepfun( uniqtR,c(0,mns2R) )\n\n\n##dif needed for test stat\nto1oR<-round(t01R[orR],10)\nstI2R<-stepfun(to1oR,c(0,WR2))\nstI1R<-stepfun(to1oR,c(0,WR))\n\n\ndif2R<-stI2R(to1oR)- mns.step2R(to1oR)\n\nKSR2<-max(abs(dif2R))\nCvMR2<-sum(dif2R**2)\n\n\ndif1R<-stI1R(to1oR)- mns.step1R(to1oR)\n\nKSR1<-max(abs(dif1R))\nCvMR1<-sum(dif1R**2)\n\n\n\n\n\n\ndifs2R<-matrix(NA,ncol=length(WsR2),nrow=N*n)\nfor (ii in 1:length(WsR2)){\ndifs2R[,ii]<-st2R[[ii]](estYs01Rr[[ii]])-mns.step2R(estYs01Rr[[ii]])\n}\nKSi2R<-apply(difs2R,2,function(x) max(abs(x)) )\nCvMi2R<-apply(difs2R,2,function(x) sum(x**2) )\n\ndifs1R<-matrix(NA,ncol=length(WsR),nrow=N*n)\nfor (ii in 1:length(WsR)){\ndifs1R[,ii]<-st1R[[ii]](estYs01Rr[[ii]])-mns.step1R(estYs01Rr[[ii]])\n}\nKSi1R<-apply(difs1R,2,function(x) max(abs(x)) )\nCvMi1R<-apply(difs1R,2,function(x) sum(x**2) )\n\n\npKSR1<-(sum(KSi1R>=KSR1)+1)/(M+1)\npCvMR1<-(sum(CvMi1R>=CvMR1)+1)/(M+1)\n\n\n pKSR2<-(sum(KSi2R>=KSR2)+1)/(M+1)\npCvMR2<-(sum(CvMi2R>=CvMR2)+1)/(M+1)\n\n\n\nres1<-c( pKSO1 ,pCvMO1, pvP.KS,pvP.CvM,pKSR1,pCvMR1)\nres2<-c( pKSO2 ,pCvMO2, pvP.KS2,pvP.CvM2,pKSR2,pCvMR2)\n\nres<-c(res1,res2)\n\n\nplot(to1o,dif2,col=\"red\",type=\"s\",ylim=c(-1,1))\nfor (ii  in 1:M){\nlines(estYs01Or[[ii]],difs2[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(to1o,dif2,col=\"red\",type=\"s\" )\n\n\nplot(estP[orP],WP2,col=\"red\",type=\"s\",ylim=c(-1,1))\nfor (ii  in 1:M){\nlines(estYiP[[ii]],WsPi2[[ii]],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(estP[orP],WP2,col=\"red\",type=\"s\" )\n\n\n\nplot(to1oR,dif2R,col=\"red\",type=\"s\",ylim=c(-1,1))\nfor (ii  in 1:M){\nlines(estYs01Rr[[ii]],difs2R[,ii],col=\"lightgray\",type=\"s\")\n\n}\n\nlines(to1oR,dif2R,col=\"red\",type=\"s\" )\n\n\n\n####olde versions\n\n\npdf(\"FiguresimEx.pdf\",height=10,width=10)\n\nset.seed(1)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\nfit<-lme(fixed=y~X2 , data=df, random=~1|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\n#plot(res,est)\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),W,xlab=\"\",ylab=txt1,type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 , data=df, random=~1|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(A), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n########\n\nfit<-lme(fixed=y~X2 , data=df, random=~1|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=0) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,type=\"s\")\n\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 , data=df, random=~1|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=0) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(B), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~1|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=0) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 +X3, data=df, random=~1|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=0) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(C), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~1|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 +X3, data=df, random=~1|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(D), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~X2|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=1) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,ylim=c(-2,0.5),type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,ylim=c(-2,0.5),type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 +X3, data=df, random=~X2|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(E), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~X2|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=0) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 +X3, data=df, random=~X2|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=0) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\n\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(F), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\ndev.off()\n\n###just a try what you get for the process designed to check the third question since here we have also random intercept\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~X2|id )\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nresi<-residuals(fit, level = 1  )\n\nest<-fitted(fit,level=0) #change if you want ordering based on yo (level=0) or yi (level=1), using level=0, works perfect\nesti<-fitted(fit,level=1)\n\nest<-esti-est\n\nor<-order(est)\nesto<-est[or]\nreso<-res[or]\nW<-1/sqrt(n*N)*cumsum(reso)\n\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\nplot(1:(N*n),W,xlab=\"\",ylab=txt1,ylim=c(-1,1),type=\"s\")\n\n\nt<-max(abs(W))\n#t<-sum(W**2)\n\nts<-rep(NA,M)\nfor (ii in 1:M){\n\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\n\nys<-esti+resi[smp]\ndf$ys<-ys\nfits<-lme(fixed=ys~X2 +X3, data=df, random=~X2|id,control=lmeControl(returnObject=TRUE) )\nress<-residuals(fits,level=1,type=\"p\")\nests<-fitted(fits,level=0) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsi<-fitted(fits,level=1)\nests<-estsi-ests\nors<-order(ests)\nestos<-ests[ors]\nresos<-ress[ors]\nWs<-1/sqrt(n*N)*cumsum(resos)\nts[ii]<-max(abs(Ws))\n\n#lines(estos,Ws,col=\"lightgray\",type=\"s\")\nlines(1:(N*n),Ws,col=\"lightgray\",type=\"s\")\n}\n#lines(esto,W,col=\"black\",type=\"s\")\nlines(1:(N*n),W,col=\"black\",type=\"s\")\n\npv<-(sum(ts>=t)+1)/(M+1)\nmtext(paste(\"(F), p=\",round(pv,4)),side=3,cex=1.2, line=0.5)\n\n\n####the usual plots\n\npdf(\"FiguresimEx2.pdf\",height=4,width=9)\n\nset.seed(1)\npar(mfrow=c(1,3))#,mar=c(2,5,3,1))\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\nfit<-lme(fixed=y~X2 , data=df, random=~1|id )\n\n\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\nplot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nabline(h=0)\nmtext(\"(A)\",side=3,cex=1.2, line=0.5)\n\n##just to be sure, comment out!\n#plot(est[df$id==10],res[df$id==10],xlab=\"Fitted values\",ylab=\"Standardized residuals\")\n#abline(h=0)\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~1|id )\n\n\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\nplot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nabline(h=0)\nmtext(\"(B)\",side=3,cex=1.2, line=0.5)\n\n\n\n########\n\nfit<-lme(fixed=y~X2+X3 , data=df, random=~X2|id )\n\n\nres<-residuals(fit, level = 1, type = c(  \"p\") )\nest<-fitted(fit,level=1)\n\nplot(est,res,xlab=\"Fitted values\",ylab=\"Standardized residuals\")\nabline(h=0)\nmtext(\"(C)\",side=3,cex=1.2, line=0.5)\n\n\ndev.off()\n\n\n##########################################\n\n##########################################\n\n\n######here is the script for the figures, but with the new standardization, where the overall performance is better\n\npdf(\"FiguresimExDifStd.pdf\",height=10,width=10)\n\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\npar(mfrow=c(3,2),mar=c(2,5,3,1))\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\n#if (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\nform.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\n#est.re2<-as.numeric(vc[2,1])\n#cov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n#D<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\nD<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WI,xlab=\"\",ylab=txt1,type=\"s\")\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\n#est.re2s<-as.numeric(vcs[2,1])\n#cov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n#Ds<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\nDs<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\nlines(1:(n*N) , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WI,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(A), p=\",round(pvI.KS,4)),side=3,cex=1.2, line=0.5)\n\n\n########\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\n\n\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+1),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\n#if (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\nform.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\n#est.re2<-as.numeric(vc[2,1])\n#cov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n#D<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\nD<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WP,xlab=\"\",ylab=txt1,type=\"s\")\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\n#est.re2s<-as.numeric(vcs[2,1])\n#cov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n#Ds<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\nDs<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\nlines(1:(n*N) , WsP,type=\"s\",col=\"lightgray\")\n\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WP,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(B), p=\",round(pvP.KS,4)),side=3,cex=1.2, line=0.5)\n\n########\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\n\n\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\n\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\n#if (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\nform.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\n#est.re2<-as.numeric(vc[2,1])\n#cov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n#D<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\nD<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WP,xlab=\"\",ylab=txt1,type=\"s\",ylim=c(-1,1))\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\n#est.re2s<-as.numeric(vcs[2,1])\n#cov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n#Ds<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\nDs<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\nlines(1:(n*N) , WsP,type=\"s\",col=\"lightgray\")\n\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WP,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(C), p=\",round(pvP.KS,4)),side=3,cex=1.2, line=0.5)\n\n\n########\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\n\n\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\n\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\n#if (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\nform.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\n#est.re2<-as.numeric(vc[2,1])\n#cov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n#D<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\nD<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WI,xlab=\"\",ylab=txt1,type=\"s\")#,ylim=c(-1,1))\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\n#est.re2s<-as.numeric(vcs[2,1])\n#cov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\n#Ds<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\nDs<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\n#Z<-cbind(1,x[df$id==gg,2])\nZ<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\nlines(1:(n*N) , WsI,type=\"s\",col=\"lightgray\")\n\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WI,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(D), p=\",round(pvI.KS,4)),side=3,cex=1.2, line=0.5)\n\n\n\n########\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\n\n\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\n\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\nif (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\n#form.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\nest.re2<-as.numeric(vc[2,1])\ncov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\nD<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\n#D<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\nZ<-cbind(1,x[df$id==gg,2])\n#Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^O )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WI,xlab=\"\",ylab=txt1,type=\"s\",ylim=c(-1,1))\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\nest.re2s<-as.numeric(vcs[2,1])\ncov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\nDs<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\n#Ds<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\nZ<-cbind(1,x[df$id==gg,2])\n#Z<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\nlines(1:(n*N) , WsI,type=\"s\",col=\"lightgray\")\n\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WI,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(E), p=\",round(pvI.KS,4)),side=3,cex=1.2, line=0.5)\n\n\n\n########\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\nset.seed(1)\n\n\nN=50\nn=25\nvar.re1<-0.25\nvar.re2<-1\nvar.fe<-0.25\n\np=1\nM=250\n\nbeta<-c(-1,0.25,0.5)#,0)#,0.5)#,1.5)\n\n\nx<-matrix(runif(N*n*p),ncol=p)\nx<-cbind(1,x,x**2)\nid<-rep(1:N,each=n)\n\n\ny<-NA\nfor (ii in 1:N){\neps<-rnorm(n,sd=sqrt(var.fe))\n\nre<-rnorm(1,sd=sqrt(var.re1))\nre2<-rnorm(1,sd=sqrt(var.re2))\n\n\nbetar<-c(beta[1]+re,beta[2]+re2,beta[-c(1,2)])\n\ny<-c(y,x[id==ii,]%*%betar+eps)\n\n\n}\ny<-y[-1]\n\ndf<-data.frame(x,id=id,y)\n\n\n#fit.model\nform<-as.formula( paste(\"y~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\nforms<-as.formula( paste(\"ys~\",paste(paste(\"X\",2:(p+2),sep=\"\") ,collapse=\"+\")  ,sep=\"\")  )\n\n\n\nform.re.int<-as.formula(\"~1|id\")\nform.re.all<-as.formula(\"~X2|id\")\n\nif (var.re2==0) form.re<-form.re.int else  form.re<- form.re.all\n#form.re<-form.re.int\n\nfit<-lme(fixed=form, data=df, random=form.re,control=lmeControl( returnObject = TRUE) )\nresIS<-residuals(fit, level = 1, type = c(  \"p\") )\nresI<-residuals(fit, level = 1  )\n#not general, only for RS also\nvc<-VarCorr(fit)\nest.re1<-as.numeric(vc[1,1])\nest.re2<-as.numeric(vc[2,1])\ncov.re<-as.numeric(vc[2,3])*sqrt(est.re1*est.re2)\nsigma.est<-as.numeric(vc[nrow(vc),1])\nD<-rbind(c(est.re1,cov.re),c(cov.re,est.re2))\n#D<-est.re1\nI<-diag(rep(1,n))\n\nresIS<-NA\nfor (gg in 1:N){\n\nZ<-cbind(1,x[df$id==gg,2])\n#Z<-matrix(1,ncol=1,nrow=n)\n\nV<-Z%*%D%*%t(Z)+sigma.est*I\nV.in<-V%^%(-0.5)\n\nresIm<-matrix(resI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISm<-V.in%*%resIm\nresIS<-c(resIS,resISm)\n}\nresIS<-resIS[-1]\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\norI<-order(estI)\norP<-order(estP)\norR<-order(estP-estI)\n\n\nresoI<-resIS[orI]\nWI<-1/sqrt(N*n)*cumsum(resoI)\n\ntI.KS<-max(abs(WI))\ntI.CvM<-sum(WI**2)\n\nresoP<-resIS[orP]\nWP<-1/sqrt(N*n)*cumsum(resoP)\n\ntP.KS<-max(abs(WP))\ntP.CvM<-sum(WP**2)\n\nresoR<-resIS[orR]\nWR<-1/sqrt(N*n)*cumsum(resoR)\n\ntR.KS<-max(abs(WR))\ntR.CvM<-sum(WR**2)\n\n#plot(estI[orI],WI,type=\"s\",ylim=c(-2,2))\n#plot((estP-estI)[orR],WR,type=\"s\",ylim=c(-2,2))\ntxt1<-expression(W^F )\n\n#plot(esto,W,xlab=\"\",ylab=txt1,type=\"s\")\nplot(1:(n*N),WP,xlab=\"\",ylab=txt1,type=\"s\",ylim=c(-1,1))\n\n\ntsI.KS<-tsI.CvM<-tsP.KS<-tsP.CvM<-tsR.KS<-tsR.CvM<-rep(NA,M)\nfor (ii in 1:M){\n#not general! only for a balanced design!\n#reshufle resids for cluster i\nsmp<-matrix(1:(n*N),ncol=n,byrow=T)\nsmp<-c(apply(smp,1,sample))\n\nys<-estI+resI[smp]\ndf$ys<-ys\nfits<-lme(fixed=forms, data=df, random=form.re ,control=lmeControl( returnObject = TRUE) )\nressIS<-residuals(fits,level=1,type=\"p\")\nressI<-residuals(fits,level=1)\nestsI<-fitted(fits,level=1) #change if you want ordering based on yo (level=0) or yi (level=1)\nestsP<-fitted(fits,level=0)\norsI<-order(estsI)\norsP<-order(estsP)\norsR<-order(estsP-estsI)\n\nvcs<-VarCorr(fits)\nest.re1s<-as.numeric(vcs[1,1])\nest.re2s<-as.numeric(vcs[2,1])\ncov.res<-as.numeric(vcs[2,3])*sqrt(est.re1s*est.re2s)\nsigma.ests<-as.numeric(vcs[nrow(vcs),1])\nDs<-rbind(c(est.re1s,cov.res),c(cov.res,est.re2s))\n#Ds<-est.re1s\n\nressIS<-NA\nfor (gg in 1:N){\n\nZ<-cbind(1,x[df$id==gg,2])\n#Z<-matrix(1,ncol=1,nrow=n)\n\nVs<-Z%*%Ds%*%t(Z)+sigma.ests*I\nV.ins<-Vs%^%(-0.5)\n\nresIms<-matrix(ressI[df$id==gg],ncol=1,nrow=n,byrow=F)\nresISms<-V.ins%*%resIms\nressIS<-c(ressIS,resISms)\n}\nressIS<-ressIS[-1]\n\n\nresosI<-ressIS[orsI]\n\n\nWsI<-1/sqrt(N*n)*cumsum(resosI)\ntsI.KS[ii]<-max(abs(WsI))\ntsI.CvM[ii]<-sum(WsI**2)\n#lines(estsI[orsI] , WsI,type=\"s\",col=\"lightgray\")\n\nresosP<-ressIS[orsP]\nWsP<-1/sqrt(N*n)*cumsum(resosP)\ntsP.KS[ii]<-max(abs(WsP))\ntsP.CvM[ii]<-sum(WsP**2)\n\nresosR<-ressIS[orsR]\nWsR<-1/sqrt(N*n)*cumsum(resosR)\ntsR.KS[ii]<-max(abs(WsR))\ntsR.CvM[ii]<-sum(WsR**2)\n#lines((estsP-estsI)[orsR],WsR,col=\"lightgray\",lty=\"s\")\nlines(1:(n*N) , WsP,type=\"s\",col=\"lightgray\")\n\n}\n# lines(estI[orI],WI,type=\"s\")\n lines(1:(n*N),WP,type=\"s\")\n\npvI.KS<- (sum(tsI.KS>=tI.KS)+1)/(M+1)\npvI.CvM<- (sum(tsI.CvM>=tI.CvM)+1)/(M+1)\n\n\npvP.KS<- (sum(tsP.KS>=tP.KS)+1)/(M+1)\npvP.CvM<- (sum(tsP.CvM>=tP.CvM)+1)/(M+1)\n\npvR.KS<- (sum(tsR.KS>=tR.KS)+1)/(M+1)\npvR.CvM<- (sum(tsR.CvM>=tR.CvM)+1)/(M+1)\nc(pvI.KS,pvI.CvM,pvP.KS,pvP.CvM,pvR.KS,pvR.CvM)\n\nmtext(paste(\"(F), p=\",round(pvP.KS,4)),side=3,cex=1.2, line=0.5)\n\n\n\ndev.off()\n\n",
    "created" : 1566372557798.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3554000409",
    "id" : "8C8030D",
    "lastKnownWriteTime" : 1566550412,
    "last_content_update" : 1566550412022,
    "path" : "E:/dropbox/Dropbox (MF Uni LJ)/gofLinearMixedModel/scriptFiguresExampleI.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}