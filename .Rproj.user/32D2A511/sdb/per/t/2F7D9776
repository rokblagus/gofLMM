{
    "collab_server" : "",
    "contents" : "\n\n\n##############################\n\n##aux functions\n\n#' Internal function\n#' @keywords internal\n\n\n\"%^%\" <- function(x, n)   with(eigen(x), vectors %*% (values^n * t(vectors)))\n\n\n\n#' Internal function\n#' @keywords internal\n\nplot.gofLMM.part<-function(W,Wm,type=c(1,2),y,ym,...){\n\nif (type==1) {x<-1:length(W);xm<-list(); for (ii in 1:length(Wm)) { xm[[ii]]<-1:length(W) }} else {x<-y[order(y)];xm=lapply(ym,function(x) x[order(x)] )}\n\nylim.min<-min( W,min(unlist(Wm)) )\nylim.max<-max( W,max(unlist(Wm)) )\n\nxlim.min<-min( min(x),min(unlist(xm)) )\nxlim.max<-max( max(x),max(unlist(xm)) )\n\nplot(x,W,col=\"white\",type=\"s\",ylim=c(ylim.min,ylim.max),xlim=c(xlim.min,xlim.max),...)\nfor (ii in 1:length(Wm)){\nlines(xm[[ii]],Wm[[ii]],type=\"s\",col=\"lightgray\",...)\n}\nlines(x,W,type=\"s\",...)\n\n}\n\n\n\n#' Internal function\n#' @keywords internal\n\nCvM<-function(x) {sum(x**2)}\n\n#' Internal function\n#' @keywords internal\n\nKS<-function(x) {max(abs(x))}\n\n#' Internal function\n#' @keywords internal\n\np.val<-function(testStat,testStatm) {(sum( testStatm>= testStat )+1)/(length(testStatm)+1)}\n\n#' Internal function\n#' @keywords internal\n\ntest.stat.p.val<-function(W,Wm){\n  ks<-KS(W)\n  cvm<-CvM(W)\n\n  ksm<-unlist(lapply(Wm,KS))\n  cvmm<-unlist(lapply(Wm,CvM))\n\n  ks.p<-p.val(ks,ksm)\n  cvm.p<-p.val(cvm,cvmm)\n\n  res<-rbind(c(ks,ks.p),c(cvm,cvm.p))\n  colnames(res)<-c(\"TestStat\",\"p.value\")\n  rownames(res)<-c(\"KS\",\"CVM\")\n  res\n}\n\n\n\n#' Internal function\n#' @keywords internal\n\n\nget.sim.proc<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,subset.fix ,order.by.original ,or.original.fitted.I ,or.original.fitted.P ,or.original.fitted.S,original.fitted.I ,original.fitted.P ,original.fitted.S,n,N,x,ZZ,id ){\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nif (order.by.original==TRUE) estI<-original.fitted.I  else estI<-fitted(fit,level=1)\nif (order.by.original==TRUE) estP<-original.fitted.P  else estP<-fitted(fit,level=0)\n\nif (order.by.original==TRUE)  orI<-or.original.fitted.I  else orI<-order(estI)\nif (order.by.original==TRUE)  orP<-or.original.fitted.P  else orP<-order(estP)\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n}\n\nH.i<-solve(H)\n\n\nJ<-list()\nA<-list()\nB<-list()\n\nres.i.c<-resI\n\n\nfor (gg in 1:N){\n\n\nif (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\nif (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\nI<-diag(rep(1,n[gg]))\n\nif (residuals==\"individual\") J[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]] else J[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\nif (residuals==\"individual\") res.i.c[id==gg]<- J[[gg]]%*% resI[id==gg] else  res.i.c[id==gg]<- J[[gg]]%*% resP[id==gg]\n\n\n\n}\n\n\n\nV.ii.inv<-list()\n\n\nif (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n\n\nresIst<-NA\nresPst<-NA\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n\n\n\n\nif (std.type==2) Si<-V.ii.inv[[gg]] else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\nresPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2<-Si%*%resPMpC\nresPMpC2<-resPMpC2\n\nresIst<-c(resIst,resPMpC2)\n\n\nresPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2P<-Si%*%resPMpCP\nresPMpC2P<-resPMpC2P\n\nresPst<-c(resPst,resPMpC2P)\n\n}\n\n\nresIst<-resIst[-1]\n resPst<-resPst[-1]\n\n\nresoI2<-resIst[orI]\n t01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\n\nWI2<-1/sqrt(N )*cumsum(resoI2)\n\nresoP2<-resPst[orP]\n t01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\n\nWP2<-1/sqrt(N )*cumsum(resoP2)\n\n\n##for Fs:\nif (!is.null(original.fitted.S)){\n\nif (order.by.original==FALSE){\nx.subset<-model.matrix(subset.fix, data=fit$data   )\ncfs.fix.sub<-fixef(fit)[colnames(x.subset)]\n\nestS<-x.subset%*%cfs.fix.sub\norS<-order(estS)\n} else {\nestS<-original.fitted.S\norS<-or.original.fitted.S\n}\n\nresoP22<-resPst[orS]\n t01P<- estS\nfor (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\nig<-which(round(t01P[orS],10)==round(ii,10))\nresoP22[ig]<-sum(resoP22[ig])/length(ig)\n}\n\nWP2s<-1/sqrt(N )*cumsum(resoP22)\n\nlist(WI2,WP2,WP2s,estI,estP,estS)\n} else list(WI2,WP2,estI,estP)\n\n}\n\n\n\n\n#' Internal function\n#' @keywords internal\n\nget.sim.proc.O<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,  order.by.original ,or.original.fitted.I , original.fitted.I  ,n,N,x,ZZ,id ){\n\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nif (order.by.original==TRUE)  estI<-original.fitted.I  else estI<-fitted(fit,level=1)\n\n\nif (order.by.original==TRUE)  orI<-or.original.fitted.I  else orI<-order(estI)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n}\n\nH.i<-solve(H)\n\n\nJ<-list()\nA<-list()\nB<-list()\n\nres.i.c<-resI\n\n\nfor (gg in 1:N){\n\n\nif (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\nif (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\nI<-diag(rep(1,n[gg]))\n\nif (residuals==\"individual\") J[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]] else J[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\nif (residuals==\"individual\") res.i.c[ id==gg]<- J[[gg]]%*% resI[ id==gg] else  res.i.c[ id==gg]<- J[[gg]]%*% resP[ id==gg]\n\n\n\n}\n\n\n\nV.ii.inv<-list()\nV.ii<-list()\n\n\n\nresIst<-NA\n\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\nV.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n\n\nif (std.type==2) Si<-V.ii.inv[[gg]] else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\nresPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2<-Si%*%resPMpC\nresPMpC2<-resPMpC2\n\nresIst<-c(resIst,resPMpC2)\n\n\n}\n\n\nresIst<-resIst[-1]\n\n\n\nresoI2<-resIst[orI]\n t01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\n\nWI2<-1/sqrt(N )*cumsum(resoI2)\n\nlist(WI2,estI)\n\n}\n\n\n#' Internal function\n#' @keywords internal\n\n\nget.sim.proc.F<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,subset.fix ,order.by.original ,  or.original.fitted.P ,or.original.fitted.S, original.fitted.P ,original.fitted.S,n,N,x,ZZ,id ){\n\n\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\n\nif (order.by.original==TRUE)  estP<-original.fitted.P else  estP<-fitted(fit,level=0)\n\n\nif (order.by.original==TRUE)  orP<-or.original.fitted.P  else orP<-order(estP)\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n}\n\nH.i<-solve(H)\n\n\n\n\nV.ii.inv<-list()\n\n\nif (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n\n\n\nresPst<-NA\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n\n\n\n\nif (std.type==2) Si<-V.ii.inv[[gg]] else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\n\n\nresPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2P<-Si%*%resPMpCP\nresPMpC2P<-resPMpC2P\n\nresPst<-c(resPst,resPMpC2P)\n\n}\n\n\n\n resPst<-resPst[-1]\n\n\nresoP2<-resPst[orP]\n t01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\n\nWP2<-1/sqrt(N )*cumsum(resoP2)\n\n\n##for Fs:\nif (!is.null(original.fitted.S)){\n\nif (order.by.original==FALSE){\nx.subset<-model.matrix(subset.fix, data=fit$data   )\ncfs.fix.sub<-fixef(fit)[colnames(x.subset)]\n\nestS<-x.subset%*%cfs.fix.sub\norS<-order(estS)\n} else {\nestS<-original.fitted.S\norS<-or.original.fitted.S\n}\n\nresoP22<-resPst[orS]\n t01P<- estS\nfor (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\nig<-which(round(t01P[orS],10)==round(ii,10))\nresoP22[ig]<-sum(resoP22[ig])/length(ig)\n}\n\nWP2s<-1/sqrt(N )*cumsum(resoP22)\n\nlist( WP2,WP2s, estP,estS)\n} else list( WP2,estP)\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n#######main function\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process. Possible values are \\code{\"individual\"} and \\code{\"cluster\"} for \\textit{individual} and \\textit{cluster-speciffic} residuals, respectively.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param  subset.fix Two-sided formula. If nonnull, the process $W^{F^s}$ will be constructed using the variables defined on the RHS of the formula. Deafults to \\code{NULL} and the process $W^{F^s}$ is not constructed.\n#' @param type How to obtain the processes $W^m$. Possible values are \\code{\"simulation\"} for the simulation approach, \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach. When using \\code{type=\"permutation\"}, sign-flipping will be used by default if not specified otherwise by the argument \\code{force.permutation.with.O}.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param order.by.original Logical. Should the residuals in the the processes $W^m$ be ordered by the original fitted values? Defaults to \\code{FALSE}.\n#' Makes sense only for \\code{type=\"sign.flip\"} and \\code{type=\"permutation\"} since when \\code{type=\"simulation\"} the ordering is always based on the original predictions.\n#' It is programmed such that J_i is reestimated at each iteration $m$.\n#' @param force.permutation.with.O Logical. Should the permutations be used also for the O process? Defaults to \\code{FALSE}.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @return An object of class \\code{\"gofLMM\"} for which \\code{plot} and \\code{summary} functions are available.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm.pan}}, \\code{\\link{plot.gofLMM}} and  \\code{\\link{summary.gofLMM}}\n#' @export\n#' @examples\n#' # simulate some data:\n#' N=50\n#' set.seed(1)\n#' n<-floor(runif(N,min=1,max=15)) #imbalanced\n#' betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE\n#' norm.eps<-FALSE\n#' shape=0.5\n#' scale=1\n#' norm.re.intercept<-FALSE\n#' shape.re.intercept=0.5\n#' scale.re.intercept=1\n#' norm.re.slope<-FALSE\n#' shape.re.slope=0.5\n#' scale.re.slope=1\n#' sim.re.slope=FALSE\n#' over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data\n#' omit.important.predictor=FALSE\n#' yy<-NA\n#' x22<-NA\n#' id<-NA\n#' x1<-NA\n#' for (gg in 1:N){\n#'\n#'   id<-c(id,rep(gg,each=n[gg]))\n#'   x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])\n#'   x1<-c(x1,x11)\n#'\n#'   if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept\n#'\n#'   b<-rep(re.int,each=n[gg])\n#'\n#'   if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope\n#'\n#'   b2<-rep(re.slope,each=n[gg])\n#'   x2<-1:n[gg]\n#'   x4<-runif(n[gg])\n#'\n#'   if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale\n#'\n#'   if (sim.re.slope==TRUE) {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4\n#'   } else {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4\n#'   }\n#'   yy<-c(yy,y)\n#'  x22<-c(x22,x2)\n#' }\n#' yy<-yy[-1]\n#' x22<-x22[-1]\n#' x1<-x1[-1]\n#' id<-id[-1]\n#' x4<-runif(sum(n))\n#' aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)\n#' library(nlme)\n#' fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' fit.gof<-gof.lmm(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= \"simulation\" ,M=25,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)\n#' plot.gofLMM(fit.gof,type=2,subset.M=NULL,xlab=\"\",main=\"Example\")\n#' summary.gofLMM(fit.gof)\n#'\n#' library(nlme)\n#' data(Orthodont)\n#' Orthodont$Subject<- rep(1:27,each=4)\n#' fm1<-lme(distance~age,random=~1|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method=\"REML\")\n#' gof.fm1<-gof.lmm(fm1,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=TRUE)\n#' plot.gofLMM(gof.fm1,type=2,subset.M=NULL,xlab=\"\",main=\"Orthodont, model 1\")\n#' summary.gofLMM(gof.fm1)\n#'\n#' fm1.1<-lme(distance~age,random=~age|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method=\"REML\")\n#' gof.fm1.1<-gof.lmm(fm1.1,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=TRUE)\n#' plot.gofLMM(gof.fm1.1 ,type=2,subset.M=NULL,xlab=\"\",main=\"Orthodont, model 1.1\")\n#' summary.gofLMM(gof.fm1.1)\n#'\n#' fm2<-lme(distance~age+Sex,random=~1|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method=\"REML\")\n#' gof.fm2<-gof.lmm(fm2,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=distance~age,type= \"sign.flip\" ,M=500,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)\n#' plot.gofLMM(gof.fm2,type=2,subset.M=NULL,xlab=\"\",main=\"Orthodont, model 2\")\n#' summary.gofLMM(gof.fm2)\n#'\n#' fm2.1<-lme(distance~age*Sex,random=~1|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method=\"REML\")\n#' gof.fm2.1<-gof.lmm(fm2.1,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= \"sign.flip\" ,M=500,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=TRUE)\n#' plot.gofLMM(gof.fm2.1,type=2,subset.M=NULL,xlab=\"\",main=\"Orthodont, model 2.1\")\n#' summary.gofLMM(gof.fm2.1)\n\n\n\ngof.lmm<-function(fit,residuals=c(\"individual\",\"cluster\"),std.type=c(1,2),use.correction.for.imbalance=FALSE,subset.fix=NULL,type=c(\"simulation\",\"sign.flip\",\"permutation\"),M=100,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=FALSE){\n\n####checks, warnings\n\nif (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\nif (verbose) cat(\"Using  \\\"verbose=FALSE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\nif (type==\"permutation\") cat(\"type=\\\"permutation\\\" is specified. \\n Using permutation for the F (and Fs) process, but sign-flipping for O process. \\n Get some snack if M is large and model is complex. \\n If \\\"force.permutation.with.O=TRUE\\\", ignore the warning and so help you god.\")\n\n\n####preliminaries\n\n\n\n\nid<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\nN<-length(unique(id))\nn<-table(id)\n\n\nid.c<-NA\nfor (ii in 1:N){\nid.c<-c(id.c,rep(ii,n[ii]))\n}\nid.c<-id.c[-1]\n\nif (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\nx<-model.matrix(fit, data=fit$data   )\n\nZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n###start gof\n\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\n\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n}\n\nH.i<-solve(H)\n\n\nJ<-list()\nA<-list()\nB<-list()\n\nres.i.c<-resI\n\n\nfor (gg in 1:N){\n\n\nif (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\nif (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\nI<-diag(rep(1,n[gg]))\n\nif (residuals==\"individual\") J[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]] else J[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\nif (residuals==\"individual\") res.i.c[id==gg]<- J[[gg]]%*% resI[id==gg] else  res.i.c[id==gg]<- J[[gg]]%*% resP[id==gg]\n\n\n\n}\n\n\n\nV.ii.inv<-list()\nV.ii<-list()\nS.i<-list()\n\nif (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n\nrespermute<-NA\nresIst<-NA\nresPst<-NA\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\nV.ii[[gg]]<-V[[gg]]%^%(0.5)\n\nresPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMp2<-V.ii.inv[[gg]]%*%resPMp\n\nrespermute<-c(respermute,resPMp2)\n\nif (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\nresPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2<-S.i[[gg]]%*%resPMpC\nresPMpC2<-resPMpC2\n\nresIst<-c(resIst,resPMpC2)\n\n\nresPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2P<-S.i[[gg]]%*%resPMpCP\nresPMpC2P<-resPMpC2P\n\nresPst<-c(resPst,resPMpC2P)\n\n}\n\nrespermute<-respermute[-1]\nresIst<-resIst[-1]\n resPst<-resPst[-1]\n\n\nresoI2<-resIst[orI]\n t01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\n\nWI2<-1/sqrt(N )*cumsum(resoI2)\n\nresoP2<-resPst[orP]\n t01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\nig<-which(round(t01P[orP],10)==round(ii,10))\nresoP2[ig]<-sum(resoP2[ig])/length(ig)\n}\n\nWP2<-1/sqrt(N )*cumsum(resoP2)\n\n\n##for Fs:\nif (!is.null(subset.fix)){\nx.subset<-model.matrix(subset.fix, data=fit$data   )\ncfs.fix.sub<-fixef(fit)[colnames(x.subset)]\n\nestS<-x.subset%*%cfs.fix.sub\norS<-order(estS)\n\nresoP22<-resPst[orS]\n t01P<- estS\nfor (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\nig<-which(round(t01P[orS],10)==round(ii,10))\nresoP22[ig]<-sum(resoP22[ig])/length(ig)\n}\n\nWP2s<-1/sqrt(N )*cumsum(resoP22)\n\nWsP21<-list()\nestSm<-list()\n} else {estS<-orS<-WsP21<-estSm<-WP2s<-NULL}\n\n\n\n\n####start sim/sign/permuted proces\n\n\nif (type==\"simulation\"){\n\n\n\n\nWsP2<- WsI2 <-list()\nestIm<-estPm<-list()\n\nfor (iiii in 1:M){\n\nif (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n\n\nsmp<-rnorm(nrow(x))\n\nnewres<-NA\nfor (gg in 1:N){\nnewres<-c(newres, V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n}\n\nnewres<-newres[-1]\n\n\n\n##prvi del procesa\n\nprvi.del.p<-prvi.del<-NA\n\nfor (gg in 1:N){\n\n  prvi.del<-c(prvi.del,S.i[[gg]]%*%J[[gg]]%*%(newres[id==gg]))\n  if (residuals==\"cluster\") prvi.del.p<-c(prvi.del.p,S.i[[gg]]%*%(newres[id==gg])) else prvi.del.p<-c(prvi.del.p,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n}\n\nprvi.del<-prvi.del[-1]\nprvi.del.p<-prvi.del.p[-1]\n\nprvi.del.o<-prvi.del[orI]\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n  ig<-which(round(t01[orI],10)==round(ii,10))\n  prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n}\n\n\nI<-1/sqrt(N)*cumsum(prvi.del.o)\nprvi.del.op<-prvi.del.p[orP]\n\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n  ig<-which(round(t01P[orP],10)==round(ii,10))\n  prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n}\n\n\nIp<-1/sqrt(N)*cumsum(prvi.del.op)\n\n\ndva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\nfor (gg  in 1:N){\n\n  if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n}\n\ndrugi.del.p<-drugi.del<-NA\n\nfor (gg in 1:N){\n\n  drugi.del<-c(drugi.del,S.i[[gg]]%*%J[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n  if (residuals==\"cluster\") drugi.del.p<-c(drugi.del.p,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1) else drugi.del.p<-c(drugi.del.p,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n}\n\ndrugi.del<-drugi.del[-1]\ndrugi.del.p<-drugi.del.p[-1]\n\ndrugi.del.o<-drugi.del[orI]\n\n\nt01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n  ig<-which(round(t01[orI],10)==round(ii,10))\n  drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n}\n\n\ndrugi.del.op<-drugi.del.p[orP]\nt01P<- estP\nfor (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n  ig<-which(round(t01P[orP],10)==round(ii,10))\n  drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n}\n\n\n\nII<-1/sqrt( N)*cumsum(drugi.del.o)\nIIp<-1/sqrt( N)*cumsum(drugi.del.op)\n\nWsI2[[iiii]]<-I-II\nWsP2[[iiii]]<-Ip-IIp\n\nestIm[[iiii]]<-estI\nestPm[[iiii]]<-estP\n\nif (!is.null(subset.fix)){\n\n\n##prvi del procesa\n\n\nprvi.del.op<-prvi.del.p[orS]\n\nt01P<- estS\nfor (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\nig<-which(round(t01P[orS],10)==round(ii,10))\nprvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n}\n\n\nIp<-1/sqrt(N)*cumsum(prvi.del.op)\n\n\n\n\ndrugi.del.op<-drugi.del.p[orS]\nt01P<- estS\nfor (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\nig<-which(round(t01P[orS],10)==round(ii,10))\ndrugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n}\n\n\nIIp<-1/sqrt( N)*cumsum(drugi.del.op)\n\nWsP21[[iiii]]<-Ip-IIp\nestSm[[iiii]]<-estS\n}\n\n}\n\n\n\n\n}\n\nif (type!=\"simulation\"){\n\nif (type==\"sign.flip\") {\n\nWsP2<- WsI2 <-list()\n estIm<-estPm<-list()\n\nfor (iiii in 1:M){\n\nif (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n\nsmp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\nys<-NA\nfor (gg in 1:N){\nys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n}\nys<-ys[-1]\n\ndatas<-fit$data\ndatas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\nfits<-suppressWarnings(update(fit,data=datas))\n\n\n\nsim.proc<-get.sim.proc(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,subset.fix=subset.fix,order.by.original=order.by.original,or.original.fitted.I=orI,or.original.fitted.P=orP,or.original.fitted.S=orS,\noriginal.fitted.I=estI ,original.fitted.P=estP ,original.fitted.S=estS,\nn=n,N=N,x=x,ZZ=ZZ,id=id)\n\n WsI2[[iiii]]<-sim.proc[[1]]\n WsP2[[iiii]]<-sim.proc[[2]]\n\nif (!is.null(subset.fix)) {\n\nWsP21[[iiii]]<-sim.proc[[3]]\nestIm[[iiii]]<-sim.proc[[4]]\nestPm[[iiii]]<-sim.proc[[5]]\nestSm[[iiii]]<-sim.proc[[6]]\n} else {\nestIm[[iiii]]<-sim.proc[[3]]\nestPm[[iiii]]<-sim.proc[[4]]\n}\n\n} #end for\n\n} else { #end if sign.flip\n\nWsP2<- WsI2 <-list()\n estIm<-estPm<-list()\n\nfor (iiii in 1:M){\n\nif (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n\nys<-NA\nfor (gg in 1:N){\n\nif (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\nys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n}\nys<-ys[-1]\n\ndatas<-fit$data\ndatas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\nfits<-suppressWarnings(update(fit,data=datas))\n\n\n\nsim.procF<-get.sim.proc.F(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,subset.fix=subset.fix,order.by.original=order.by.original,or.original.fitted.P=orP,or.original.fitted.S=orS,\noriginal.fitted.P=estP ,original.fitted.S=estS,\nn=n,N=N,x=x,ZZ=ZZ,id=id)\n\n\nif (!is.null(subset.fix)) {WsP2[[iiii]]<-sim.procF[[1]];WsP21[[iiii]]<-sim.procF[[2]];estPm[[iiii]]<-sim.procF[[3]];estSm[[iiii]]<-sim.procF[[4]]} else  {WsP2[[iiii]]<-sim.procF[[1]];estPm[[iiii]]<-sim.procF[[2]] }\n\n\n###needed to force sign-flipp for O\n\nif (force.permutation.with.O==FALSE){\n\nsmp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\nys<-NA\nfor (gg in 1:N){\nys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n}\nys<-ys[-1]\n\ndatas<-fit$data\ndatas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\nfits<-suppressWarnings(update(fit,data=datas))\n\n}\n\nsim.procO<-get.sim.proc.O(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance, order.by.original=order.by.original,or.original.fitted.I=orI,\noriginal.fitted.I=estI ,\nn=n,N=N,x=x,ZZ=ZZ,id=id)\n\nWsI2[[iiii]]<-sim.procO[[1]]\nestIm[[iiii]]<-sim.procO[[2]]\n\n} #end for\n\n} #end of else\n\n} #end if not sim\n\n\n\n\n\nres<-list(O=WI2,F=WP2,Om=WsI2,Fm=WsP2,Fs=WP2s,Fsm=WsP21,predO=estI,predOm=estIm,predF=estP,predFm=estPm,predFs=estS,predFsm=estSm)\nclass(res)<-\"gofLMM\"\nres\n\n\n} #end of function\n\n\n\n\n\n\n\n\n\n#fit #result of call to gofLMM\n#type #type of x-axis, 1=1:N, 2=y.hat\n#subset.M #how many random permutations to plot\n\n#' Plot Function\n#'\n#' plots the processes which are the result of a call to \\code{gof.lmm}\n#'\n#' @param object an object of class \\code{\"gofLMM\"}, an object returned by a call to \\code{\\link{gof.lmm}}\n#' @param type Type of x-axis. Possible values are 1 for 1:N and 2 for the predicted values. Defaults to 2.\n#' @param subset.M How many realizations of $W^m$ should be plotted. Defaults to NULL and all the realizations are plotted.\n#' @param ... additional arguments passed to from or to other methods\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm.pan}}, \\code{\\link{gof.lmm}} and \\code{\\link{summary.gofLMM}}\n#' @export\n\n\nplot.gofLMM<-function(object,type=2,subset.M=NULL,...){\n\ntxt1<-expression(W^O)\ntxt2<-expression(W^F)\ntxt3<-expression(W^F^S)\n\nif (is.null(object$Fs)) par(mfrow=c(1,2)) else par(mfrow=c(1,3))\n\nif (is.null(subset.M)) sbset<-1:length(object$Om) else sbset<-sample(1:length(object$Om),subset.M)\n\n\nplot.gofLMM.part(object$O,object$Om[sbset],type=type,y=object$predO,ym=object$predOm[sbset],ylab=txt1,...)\nplot.gofLMM.part(object$F,object$Fm[sbset],type=type,y=object$predF,ym=object$predFm[sbset],ylab=txt2,...)\n\nif (!is.null(object$Fs))  plot.gofLMM.part(object$Fs,object$Fsm[sbset],type=type,y=object$predFs,ym=object$predFsm[sbset],ylab=txt3,...)\n\n\n\n}\n\n\n\n#' Summary Function\n#'\n#' makes a summary of a call to \\code{gof.lmm}\n#'\n#' @param object an object of class \\code{\"gofLMM\"}, an object returned by a call to \\code{\\link{gof.lmm}}\n#' @param conf.level the confidence level, defaults to 0.95\n#' @param ... additional arguments affecting the summary produced.\n\n#' @return a matrix containing KS and CvM test statistics and corresponding $p$-values for the constructed processes.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm.pan}}, \\code{\\link{gof.lmm}} and \\code{\\link{plot.gofLMM}}\n#' @export\n\n\nsummary.gofLMM<-function(object){\n\nO.s<-test.stat.p.val(object$O,object$Om)\nF.s<-test.stat.p.val(object$F,object$Fm)\nif (!is.null(object$Fs))  S.s<-test.stat.p.val(object$Fs,object$Fsm) else S.s<-NULL\n\nres<-rbind(O.s,F.s,S.s)\nif (!is.null(object$Fs)) rownames(res)<-c(paste(\"O\",rownames(res)[1:2],sep=\":\"),paste(\"F\",rownames(res)[1:2],sep=\":\")  ,paste(\"Fs\",rownames(res)[1:2],sep=\":\") ) else rownames(res)<-c(paste(\"O\",rownames(res)[1:2],sep=\":\"),paste(\"F\",rownames(res)[1:2],sep=\":\"))\n\nres\n\n}\n\n\n#' Print Function\n#'\n#' prints results from a call to \\code{gof.lmm}\n#'\n#' @param object an object of class \\code{\"gofLMM\"}, an object returned by a call to \\code{\\link{gof.lmm}}\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm}}, \\code{\\link{summary.gofLMM}} and \\code{\\link{plot.gofLMM}}\n#' @export\n\n\nprint.gofLMM<-function(object){\n\n  cat(\"Cumsum process.\")\n\n}\n\n\n\n\n#######main function\n\n#' Goodness-of fit test for LMM as proposed by Pan et al.\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process using the simulation approach proposed by Pan et al.\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N !\n#' @param residuals Residuals to be used when constructing the process. Possible values are \\code{\"individual\"} and \\code{\"cluster\"} for \\textit{individual} and \\textit{cluster-speciffic} residuals, respectively.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param  subset.fix Two-sided formula. If nonnull, the process $W^{F^s}$ will be constructed using the variables defined on the RHS of the formula. Deafults to \\code{NULL} and the process $W^{F^s}$ is not constructed.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @return An object of class \\code{\"gofLMM\"} for which \\code{plot} and \\code{summary} functions are available.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm}}, \\code{\\link{plot.gofLMM}} and  \\code{\\link{summary.gofLMM}}\n#' @export\n#' @examples\n#' # simulate some data:\n#' N=50\n#' set.seed(1)\n#' n<-floor(runif(N,min=1,max=15)) #imbalanced\n#' betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE\n#' norm.eps<-FALSE\n#' shape=0.5\n#' scale=1\n#' norm.re.intercept<-FALSE\n#' shape.re.intercept=0.5\n#' scale.re.intercept=1\n#' norm.re.slope<-FALSE\n#' shape.re.slope=0.5\n#' scale.re.slope=1\n#' sim.re.slope=FALSE\n#' over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data\n#' omit.important.predictor=FALSE\n#' yy<-NA\n#' x22<-NA\n#' id<-NA\n#' x1<-NA\n#' for (gg in 1:N){\n#'\n#'   id<-c(id,rep(gg,each=n[gg]))\n#'   x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])\n#'   x1<-c(x1,x11)\n#'\n#'   if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept\n#'\n#'   b<-rep(re.int,each=n[gg])\n#'\n#'   if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope\n#'\n#'   b2<-rep(re.slope,each=n[gg])\n#'   x2<-1:n[gg]\n#'   x4<-runif(n[gg])\n#'\n#'   if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale\n#'\n#'   if (sim.re.slope==TRUE) {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4\n#'   } else {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4\n#'   }\n#'   yy<-c(yy,y)\n#'  x22<-c(x22,x2)\n#' }\n#' yy<-yy[-1]\n#' x22<-x22[-1]\n#' x1<-x1[-1]\n#' id<-id[-1]\n#' x4<-runif(sum(n))\n#' aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)\n#' library(nlme)\n#' fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' fit.gof.pan<-gof.lmm.pan(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,M=25,verbose=TRUE)\n#' plot.gofLMM(fit.gof.pan,type=2,subset.M=NULL,xlab=\"\",main=\"Example\")\n#' summary.gofLMM(fit.gof.pan)\n\n\ngof.lmm.pan<-function(fit,residuals=c(\"individual\",\"cluster\"),std.type=c(1,2),use.correction.for.imbalance=FALSE,subset.fix=NULL,M=100,verbose=FALSE){\n\n  ####checks, warnings\n\n\n  if (verbose) cat(\"Using  \\\"verbose=FALSE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\n\n  ####preliminaries\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n\n  id.c<-NA\n  for (ii in 1:N){\n    id.c<-c(id.c,rep(ii,n[ii]))\n  }\n  id.c<-id.c[-1]\n\n  if (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  J<-list()\n  A<-list()\n  B<-list()\n\n  res.i.c<-resI\n\n\n  for (gg in 1:N){\n\n\n    if (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    if (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\n    I<-diag(rep(1,n[gg]))\n\n    if (residuals==\"individual\") J[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]] else J[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\n    if (residuals==\"individual\") res.i.c[id==gg]<- J[[gg]]%*% resI[id==gg] else  res.i.c[id==gg]<- J[[gg]]%*% resP[id==gg]\n\n\n\n  }\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n  if (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n\n  respermute<-resP\n  resIst<-NA\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst<-c(resIst,resPMpC2)\n\n\n    resPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst<-c(resPst,resPMpC2P)\n\n  }\n\n   resIst<-resIst[-1]\n  resPst<-resPst[-1]\n\n\n  resoI2<-resIst[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2<-1/sqrt(N )*cumsum(resoP2)\n\n\n  ##for Fs:\n  if (!is.null(subset.fix)){\n    x.subset<-model.matrix(subset.fix, data=fit$data   )\n    cfs.fix.sub<-fixef(fit)[colnames(x.subset)]\n\n    estS<-x.subset%*%cfs.fix.sub\n    orS<-order(estS)\n\n    resoP22<-resPst[orS]\n    t01P<- estS\n    for (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\n      ig<-which(round(t01P[orS],10)==round(ii,10))\n      resoP22[ig]<-sum(resoP22[ig])/length(ig)\n    }\n\n    WP2s<-1/sqrt(N )*cumsum(resoP22)\n\n    WsP21<-list()\n    estSm<-list()\n  } else {estS<-orS<-WsP21<-estSm<-WP2s<-NULL}\n\n\n\n\n  ####start sim/sign/permuted proces\n\n\n\n\n\n\n    WsP2<- WsI2 <-list()\n    estIm<-estPm<-list()\n\n    for (iiii in 1:M){\n\n      if (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n\n\n\n\n      newres<-NA\n      for (gg in 1:N){\n        smp<-rnorm(1)\n        newres<-c(newres,  (respermute*smp)[id==gg])\n      }\n\n      newres<-newres[-1]\n\n\n\n\n      ##prvi del procesa\n\n      prvi.del.p<-prvi.del<-NA\n\n      for (gg in 1:N){\n\n        prvi.del<-c(prvi.del,S.i[[gg]]%*%J[[gg]]%*%(newres[id==gg]))\n        if (residuals==\"cluster\") prvi.del.p<-c(prvi.del.p,S.i[[gg]]%*%(newres[id==gg])) else prvi.del.p<-c(prvi.del.p,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n      }\n\n      prvi.del<-prvi.del[-1]\n      prvi.del.p<-prvi.del.p[-1]\n\n      prvi.del.o<-prvi.del[orI]\n\n      t01<- estI\n\n      for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n        ig<-which(round(t01[orI],10)==round(ii,10))\n        prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n      }\n\n\n      I<-1/sqrt(N)*cumsum(prvi.del.o)\n      prvi.del.op<-prvi.del.p[orP]\n\n      t01P<- estP\n      for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n        ig<-which(round(t01P[orP],10)==round(ii,10))\n        prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n      }\n\n\n      Ip<-1/sqrt(N)*cumsum(prvi.del.op)\n\n\n      dva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\n      for (gg  in 1:N){\n\n        if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n      }\n\n      drugi.del.p<-drugi.del<-NA\n\n      for (gg in 1:N){\n\n        drugi.del<-c(drugi.del,S.i[[gg]]%*%J[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n        if (residuals==\"cluster\") drugi.del.p<-c(drugi.del.p,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1) else drugi.del.p<-c(drugi.del.p,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n      }\n\n      drugi.del<-drugi.del[-1]\n      drugi.del.p<-drugi.del.p[-1]\n\n      drugi.del.o<-drugi.del[orI]\n\n\n      t01<- estI\n\n      for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n        ig<-which(round(t01[orI],10)==round(ii,10))\n        drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n      }\n\n\n      drugi.del.op<-drugi.del.p[orP]\n      t01P<- estP\n      for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n        ig<-which(round(t01P[orP],10)==round(ii,10))\n        drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n      }\n\n\n\n      II<-1/sqrt( N)*cumsum(drugi.del.o)\n      IIp<-1/sqrt( N)*cumsum(drugi.del.op)\n\n      WsI2[[iiii]]<-I-II\n      WsP2[[iiii]]<-Ip-IIp\n\n      estIm[[iiii]]<-estI\n      estPm[[iiii]]<-estP\n\n      if (!is.null(subset.fix)){\n\n        ##prvi del procesa\n\n\n        prvi.del.op<-prvi.del.p[orS]\n\n        t01P<- estS\n        for (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\n          ig<-which(round(t01P[orS],10)==round(ii,10))\n          prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n        }\n\n\n        Ip<-1/sqrt(N)*cumsum(prvi.del.op)\n\n\n\n\n        drugi.del.op<-drugi.del.p[orS]\n        t01P<- estS\n        for (ii in as.numeric(names(table(t01P[orS]))[which(table(t01P[orS])>1)])){\n          ig<-which(round(t01P[orS],10)==round(ii,10))\n          drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n        }\n\n\n        IIp<-1/sqrt( N)*cumsum(drugi.del.op)\n\n        WsP21[[iiii]]<-Ip-IIp\n        estSm[[iiii]]<-estS\n      }\n\n    }\n\n\n\n\n\n  res<-list(O=WI2,F=WP2,Om=WsI2,Fm=WsP2,Fs=WP2s,Fsm=WsP21,predO=estI,predOm=estIm,predF=estP,predFm=estPm,predFs=estS,predFsm=estSm)\n  class(res)<-\"gofLMM\"\n  res\n\n\n} #end of function\n\n\n\n\n\n\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\n\nget.sim.proc.fast.ororg<-function(fit, std.type ,use.correction.for.imbalance ,n,N,x,ZZ,id,fittedI, or.fittedI,fittedP,or.fittedP ){\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<- fittedI\n  estP<- fittedP\n\n  orI<- or.fittedI\n  orP<- or.fittedP\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n\n  res.i.c.ind<-resI\n\n  res.i.c.clust<-resP\n\n  for (gg in 1:N){\n\n\n    if (n[gg]!=1) A<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    if (n[gg]!=1) B<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\n    I<-diag(rep(1,n[gg]))\n\n    J.ind<-sigma.est*V.i[[gg]]-(A)%*%ginv(B)%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n    J.clust<-I-(A+B)%*%ginv(B)%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\n    res.i.c.ind[id==gg]<- J.ind%*% resI[id==gg]\n    res.i.c.clust[id==gg]<- J.clust%*% resP[id==gg]\n\n\n\n  }\n\n\n\n\n  res.i.c2.ind<-resI\n  res.i.c2.clust<-resP\n\n\n  resIst.ind<-NA\n  resPst.ind<-NA\n\n  resIst.clust<-NA\n  resPst.clust<-NA\n\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv<-V[[gg]]%^%(-0.5)\n\n\n\n\n    if (std.type==2) Si<-V.ii.inv else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-Si%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.ind<-c(resIst.ind,resPMpC2)\n\n\n    resPMpCP<-matrix(res.i.c2.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-Si%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.ind<-c(resPst.ind,resPMpC2P)\n\n    resPMpC<-matrix(res.i.c.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-Si%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.clust<-c(resIst.clust,resPMpC2)\n\n\n    resPMpCP<-matrix(res.i.c2.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-Si%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.clust<-c(resPst.clust,resPMpC2P)\n\n  }\n\n\n  resIst.ind<-resIst.ind[-1]\n  resPst.ind<-resPst.ind[-1]\n\n  resIst.clust<-resIst.clust[-1]\n  resPst.clust<-resPst.clust[-1]\n\n\n  resoI2<-resIst.ind[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.ind<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.ind[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.ind<-1/sqrt(N )*cumsum(resoP2)\n\n\n  resoI2<-resIst.clust[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.clust<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.clust[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.clust<-1/sqrt(N )*cumsum(resoP2)\n\n  list(WI2.ind,WP2.ind,WI2.clust,WP2.clust)\n\n}\n\n\n\n\n\n#######sim function\n\n#' Goodness-of fit test for LMM, all faster, ordering the residuals by the original fitted values also for the SF and permutation approach\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process. Used for simulations. Returns only KS and CvM p-values for all 4 methods and individual as well as cluster specific residuals. Fs not implemented here.\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}; ID variable must be numeric and ordered from 1:N !.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @return KS and CvM pvalues for Pan, Simulation, sign-flip and permutations.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @details for sign.flip and permutation the residuals are ordered by the refitted fitted values.\n#' @seealso \\code{\\link{gof.lmm.pan}} and \\code{\\link{gof.lmm}}\n#' @export\n#' @examples\n#' # simulate some data:\n#' N=50\n#' set.seed(1)\n#' n<-floor(runif(N,min=1,max=15)) #imbalanced\n#' betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE\n#' norm.eps<-FALSE\n#' shape=0.5\n#' scale=1\n#' norm.re.intercept<-FALSE\n#' shape.re.intercept=0.5\n#' scale.re.intercept=1\n#' norm.re.slope<-FALSE\n#' shape.re.slope=0.5\n#' scale.re.slope=1\n#' sim.re.slope=FALSE\n#' over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data\n#' omit.important.predictor=FALSE\n#' yy<-NA\n#' x22<-NA\n#' id<-NA\n#' x1<-NA\n#' for (gg in 1:N){\n#'\n#'   id<-c(id,rep(gg,each=n[gg]))\n#'   x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])\n#'   x1<-c(x1,x11)\n#'\n#'   if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept\n#'\n#'   b<-rep(re.int,each=n[gg])\n#'\n#'   if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope\n#'\n#'   b2<-rep(re.slope,each=n[gg])\n#'   x2<-1:n[gg]\n#'   x4<-runif(n[gg])\n#'\n#'   if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale\n#'\n#'   if (sim.re.slope==TRUE) {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4\n#'   } else {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4\n#'   }\n#'   yy<-c(yy,y)\n#'  x22<-c(x22,x2)\n#' }\n#' yy<-yy[-1]\n#' x22<-x22[-1]\n#' x1<-x1[-1]\n#' id<-id[-1]\n#' x4<-runif(sum(n))\n#' aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)\n#' library(nlme)\n#' fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' gof.lmm.sim.orderbyoriginal(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)\n\n\ngof.lmm.sim.orderbyoriginal<-function(fit,std.type=c(1,2),use.correction.for.imbalance=FALSE,M=100,verbose=FALSE){\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  J.ind<-list()\n  J.clust<-list()\n  A<-list()\n  B<-list()\n\n  res.i.c.ind<-resI\n  res.i.c.clust<-resP\n\n  for (gg in 1:N){\n\n\n    if (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    if (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\n    I<-diag(rep(1,n[gg]))\n\n    J.ind[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n    J.clust[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\n    res.i.c.ind[id==gg]<- J.ind[[gg]]%*% resI[id==gg]\n    res.i.c.clust[id==gg]<- J.clust[[gg]]%*% resP[id==gg]\n\n\n\n  }\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n  res.i.c2.ind<-resI\n  res.i.c2.clust<-resP\n\n  respermute<-NA\n  resIst.ind<-NA\n  resPst.ind<-NA\n  resIst.clust<-NA\n  resPst.clust<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.ind<-c(resIst.ind,resPMpC2)\n\n    resPMpC<-matrix(res.i.c.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.clust<-c(resIst.clust,resPMpC2)\n\n    resPMpCP<-matrix(res.i.c2.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.ind<-c(resPst.ind,resPMpC2P)\n\n    resPMpCP<-matrix(res.i.c2.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.clust<-c(resPst.clust,resPMpC2P)\n  }\n\n  respermute<-respermute[-1]\n  resIst.ind<-resIst.ind[-1]\n  resPst.ind<-resPst.ind[-1]\n  resIst.clust<-resIst.clust[-1]\n  resPst.clust<-resPst.clust[-1]\n\n  resoI2<-resIst.ind[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.ind<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.ind[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.ind<-1/sqrt(N )*cumsum(resoP2)\n\n\n\n  resoI2<-resIst.clust[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.clust<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.clust[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.clust<-1/sqrt(N )*cumsum(resoP2)\n\n\n\n  ####start sim/sign/permuted proces\n\n  ###simulation, Pan approach\n\n\n  WsP2.ind<- WsI2.ind <-list()\n\n  WsP2.clust<- WsI2.clust <-list()\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Simulation Pan: \",iiii,sep=\"\"))\n\n\n\n\n    newres<-NA\n    for (gg in 1:N){\n      smp<-rnorm(1)\n      newres<-c(newres, ( (resP*smp)[id==gg]))\n    }\n\n    newres<-newres[-1]\n\n\n\n    ##prvi del procesa\n\n    prvi.del.p.ind<-prvi.del.ind<-prvi.del.p.clust<-prvi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      prvi.del.ind<-c(prvi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%(newres[id==gg]))\n      prvi.del.clust<-c(prvi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%(newres[id==gg]))\n\n      prvi.del.p.clust<-c(prvi.del.p.clust,S.i[[gg]]%*%(newres[id==gg]))\n      prvi.del.p.ind<-c(prvi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n    }\n\n    prvi.del.ind<-prvi.del.ind[-1]\n    prvi.del.p.ind<-prvi.del.p.ind[-1]\n\n    prvi.del.clust<-prvi.del.clust[-1]\n    prvi.del.p.clust<-prvi.del.p.clust[-1]\n\n    prvi.del.o<-prvi.del.ind[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iind<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.o<-prvi.del.clust[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iclust<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.op<-prvi.del.p.ind[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipind<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    prvi.del.op<-prvi.del.p.clust[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipclust<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    dva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\n    for (gg  in 1:N){\n\n      if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n    }\n\n    drugi.del.p.ind<-drugi.del.ind<-drugi.del.p.clust<-drugi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      drugi.del.ind<-c(drugi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.clust<-c(drugi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n      drugi.del.p.clust<-c(drugi.del.p.clust,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.p.ind<-c(drugi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n    }\n\n    drugi.del.ind<-drugi.del.ind[-1]\n    drugi.del.p.ind<-drugi.del.p.ind[-1]\n\n    drugi.del.clust<-drugi.del.clust[-1]\n    drugi.del.p.clust<-drugi.del.p.clust[-1]\n\n    drugi.del.o<-drugi.del.ind[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.ind[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIind<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpind<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    drugi.del.o<-drugi.del.clust[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.clust[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIclust<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpclust<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    WsI2.ind[[iiii]]<-Iind-IIind\n    WsP2.ind[[iiii]]<-Ipind-IIpind\n\n    WsI2.clust[[iiii]]<-Iclust-IIclust\n    WsP2.clust[[iiii]]<-Ipclust-IIpclust\n\n\n\n\n\n  }\n\n  res.sim.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n\n  res.sim.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n  ###simulation, our approach\n\n\n\n\n  WsP2.ind<- WsI2.ind <-list()\n\n  WsP2.clust<- WsI2.clust <-list()\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Simulation: \",iiii,sep=\"\"))\n\n\n\n    smp<-rnorm(nrow(x))\n\n    newres<-NA\n    for (gg in 1:N){\n      newres<-c(newres, V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n    }\n\n    newres<-newres[-1]\n\n\n\n    ##prvi del procesa\n\n    prvi.del.p.ind<-prvi.del.ind<-prvi.del.p.clust<-prvi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      prvi.del.ind<-c(prvi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%(newres[id==gg]))\n      prvi.del.clust<-c(prvi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%(newres[id==gg]))\n\n      prvi.del.p.clust<-c(prvi.del.p.clust,S.i[[gg]]%*%(newres[id==gg]))\n      prvi.del.p.ind<-c(prvi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n    }\n\n    prvi.del.ind<-prvi.del.ind[-1]\n    prvi.del.p.ind<-prvi.del.p.ind[-1]\n\n    prvi.del.clust<-prvi.del.clust[-1]\n    prvi.del.p.clust<-prvi.del.p.clust[-1]\n\n    prvi.del.o<-prvi.del.ind[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iind<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.o<-prvi.del.clust[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iclust<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.op<-prvi.del.p.ind[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipind<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    prvi.del.op<-prvi.del.p.clust[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipclust<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    dva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\n    for (gg  in 1:N){\n\n      if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n    }\n\n    drugi.del.p.ind<-drugi.del.ind<-drugi.del.p.clust<-drugi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      drugi.del.ind<-c(drugi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.clust<-c(drugi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n      drugi.del.p.clust<-c(drugi.del.p.clust,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.p.ind<-c(drugi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n    }\n\n    drugi.del.ind<-drugi.del.ind[-1]\n    drugi.del.p.ind<-drugi.del.p.ind[-1]\n\n    drugi.del.clust<-drugi.del.clust[-1]\n    drugi.del.p.clust<-drugi.del.p.clust[-1]\n\n    drugi.del.o<-drugi.del.ind[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.ind[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIind<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpind<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    drugi.del.o<-drugi.del.clust[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.clust[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIclust<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpclust<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    WsI2.ind[[iiii]]<-Iind-IIind\n    WsP2.ind[[iiii]]<-Ipind-IIpind\n\n    WsI2.clust[[iiii]]<-Iclust-IIclust\n    WsP2.clust[[iiii]]<-Ipclust-IIpclust\n\n\n\n\n\n  }\n\n  res.sim.our.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n\n  res.sim.our.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n\n\n\n\n\n\n\n  WsP2.ind<- WsI2.ind <-list()\n  WsP2.clust<- WsI2.clust <-list()\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Sign-flip: \",iiii,sep=\"\"))\n\n    smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n    ys<-NA\n    for (gg in 1:N){\n      ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n    }\n    ys<-ys[-1]\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.fast.ororg(fits, std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,\n                                n=n,N=N,x=x,ZZ=ZZ,id=id,fittedI=estI, or.fittedI=orI,fittedP=estP,or.fittedP=orP)\n\n    WsI2.ind[[iiii]]<-sim.proc[[1]]\n    WsP2.ind[[iiii]]<-sim.proc[[2]]\n\n\n    WsI2.clust[[iiii]]<-sim.proc[[3]]\n    WsP2.clust[[iiii]]<-sim.proc[[4]]\n\n\n  } #end for\n\n\n  res.sign.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n  res.sign.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n\n  WsP2.ind<- WsI2.ind <-list()\n  WsP2.clust<- WsI2.clust <-list()\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Permutation: \",iiii,sep=\"\"))\n\n    ys<-NA\n    for (gg in 1:N){\n\n      if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n      ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n    }\n    ys<-ys[-1]\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.fast.ororg(fits, std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,\n                                      n=n,N=N,x=x,ZZ=ZZ,id=id,fittedI=estI, or.fittedI=orI,fittedP=estP,or.fittedP=orP)\n    WsI2.ind[[iiii]]<-sim.proc[[1]]\n    WsP2.ind[[iiii]]<-sim.proc[[2]]\n\n\n    WsI2.clust[[iiii]]<-sim.proc[[3]]\n    WsP2.clust[[iiii]]<-sim.proc[[4]]\n\n  } #end for\n\n\n  res.perm.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n  res.perm.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n\n  res.ind<-c(res.sim.ind,res.sim.our.ind, res.sign.ind,res.perm.ind)\n  res.clust<-c(res.sim.clust,res.sim.our.clust, res.sign.clust,res.perm.clust)\n\n  names(res.ind)<-names(res.clust)<-c(\n    paste(\"Sim\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n    paste(\"SimOur\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n    paste(\"Sign\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n    paste(\"Perm\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\")\n  )\n\n  resm.ind<-matrix(res.ind,ncol=4,byrow=T)\n  resm.clust<-matrix(res.clust,ncol=4,byrow=T)\n\n\n  colnames(resm.ind)<-colnames(resm.clust)<-c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\")\n  rownames(resm.ind)<-rownames(resm.clust)<-c(\"Simulation.Pan\",\"Simulation\",\"sign.flip\",\"permutation\")\n  list(results.ind=res.ind,results.matrix.ind=resm.ind,results.clust=res.clust,results.matrix.clust=resm.clust)\n} #end of function\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\n\nget.sim.proc.fast<-function(fit, std.type ,use.correction.for.imbalance ,n,N,x,ZZ,id ){\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n   estI<-fitted(fit,level=1)\n   estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n\n  res.i.c.ind<-resI\n\n  res.i.c.clust<-resP\n\n  for (gg in 1:N){\n\n\n    if (n[gg]!=1) A<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    if (n[gg]!=1) B<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\n    I<-diag(rep(1,n[gg]))\n\n    J.ind<-sigma.est*V.i[[gg]]-(A)%*%ginv(B)%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n    J.clust<-I-(A+B)%*%ginv(B)%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\n    res.i.c.ind[id==gg]<- J.ind%*% resI[id==gg]\n    res.i.c.clust[id==gg]<- J.clust%*% resP[id==gg]\n\n\n\n  }\n\n\n\n\n  res.i.c2.ind<-resI\n  res.i.c2.clust<-resP\n\n\n  resIst.ind<-NA\n  resPst.ind<-NA\n\n  resIst.clust<-NA\n  resPst.clust<-NA\n\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv<-V[[gg]]%^%(-0.5)\n\n\n\n\n    if (std.type==2) Si<-V.ii.inv else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-Si%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.ind<-c(resIst.ind,resPMpC2)\n\n\n    resPMpCP<-matrix(res.i.c2.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-Si%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.ind<-c(resPst.ind,resPMpC2P)\n\n    resPMpC<-matrix(res.i.c.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-Si%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.clust<-c(resIst.clust,resPMpC2)\n\n\n    resPMpCP<-matrix(res.i.c2.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-Si%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.clust<-c(resPst.clust,resPMpC2P)\n\n  }\n\n\n  resIst.ind<-resIst.ind[-1]\n  resPst.ind<-resPst.ind[-1]\n\n  resIst.clust<-resIst.clust[-1]\n  resPst.clust<-resPst.clust[-1]\n\n\n  resoI2<-resIst.ind[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.ind<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.ind[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.ind<-1/sqrt(N )*cumsum(resoP2)\n\n\n  resoI2<-resIst.clust[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.clust<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.clust[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.clust<-1/sqrt(N )*cumsum(resoP2)\n\n   list(WI2.ind,WP2.ind,WI2.clust,WP2.clust)\n\n}\n\n\n\n\n\n#######sim function\n\n#' Goodness-of fit test for LMM, all faster\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process. Used for simulations. Returns only KS and CvM p-values for all 4 methods and individual as well as cluster specific residuals. Fs not implemented here.\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}; ID variable must be numeric and ordered from 1:N !.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @return KS and CvM pvalues for Pan, Simulation, sign-flip and permutations.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @details for sign.flip and permutation the residuals are ordered by the refitted fitted values.\n#' @seealso \\code{\\link{gof.lmm.pan}} and \\code{\\link{gof.lmm}}\n#' @export\n#' @examples\n#' # simulate some data:\n#' N=50\n#' set.seed(1)\n#' n<-floor(runif(N,min=1,max=15)) #imbalanced\n#' betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE\n#' norm.eps<-FALSE\n#' shape=0.5\n#' scale=1\n#' norm.re.intercept<-FALSE\n#' shape.re.intercept=0.5\n#' scale.re.intercept=1\n#' norm.re.slope<-FALSE\n#' shape.re.slope=0.5\n#' scale.re.slope=1\n#' sim.re.slope=FALSE\n#' over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data\n#' omit.important.predictor=FALSE\n#' yy<-NA\n#' x22<-NA\n#' id<-NA\n#' x1<-NA\n#' for (gg in 1:N){\n#'\n#'   id<-c(id,rep(gg,each=n[gg]))\n#'   x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])\n#'   x1<-c(x1,x11)\n#'\n#'   if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept\n#'\n#'   b<-rep(re.int,each=n[gg])\n#'\n#'   if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope\n#'\n#'   b2<-rep(re.slope,each=n[gg])\n#'   x2<-1:n[gg]\n#'   x4<-runif(n[gg])\n#'\n#'   if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale\n#'\n#'   if (sim.re.slope==TRUE) {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4\n#'   } else {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4\n#'   }\n#'   yy<-c(yy,y)\n#'  x22<-c(x22,x2)\n#' }\n#' yy<-yy[-1]\n#' x22<-x22[-1]\n#' x1<-x1[-1]\n#' id<-id[-1]\n#' x4<-runif(sum(n))\n#' aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)\n#' library(nlme)\n#' fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' gof.lmm.sim(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)\n\n\ngof.lmm.sim<-function(fit,std.type=c(1,2),use.correction.for.imbalance=FALSE,M=100,verbose=FALSE){\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  J.ind<-list()\n  J.clust<-list()\n  A<-list()\n  B<-list()\n\n  res.i.c.ind<-resI\n  res.i.c.clust<-resP\n\n  for (gg in 1:N){\n\n\n    if (n[gg]!=1) A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else A[[gg]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    if (n[gg]!=1) B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%t(x[id==gg,]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]]) else B[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- x[id==gg,]%*%H.i%*%matrix(x[id==gg,],ncol=1) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n\n\n    I<-diag(rep(1,n[gg]))\n\n    J.ind[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n    J.clust[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]\n\n\n    res.i.c.ind[id==gg]<- J.ind[[gg]]%*% resI[id==gg]\n    res.i.c.clust[id==gg]<- J.clust[[gg]]%*% resP[id==gg]\n\n\n\n  }\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n  res.i.c2.ind<-resI\n  res.i.c2.clust<-resP\n\n  respermute<-NA\n  resIst.ind<-NA\n  resPst.ind<-NA\n  resIst.clust<-NA\n  resPst.clust<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.ind<-c(resIst.ind,resPMpC2)\n\n    resPMpC<-matrix(res.i.c.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst.clust<-c(resIst.clust,resPMpC2)\n\n    resPMpCP<-matrix(res.i.c2.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.ind<-c(resPst.ind,resPMpC2P)\n\n    resPMpCP<-matrix(res.i.c2.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst.clust<-c(resPst.clust,resPMpC2P)\n  }\n\n  respermute<-respermute[-1]\n  resIst.ind<-resIst.ind[-1]\n  resPst.ind<-resPst.ind[-1]\n  resIst.clust<-resIst.clust[-1]\n  resPst.clust<-resPst.clust[-1]\n\n  resoI2<-resIst.ind[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.ind<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.ind[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.ind<-1/sqrt(N )*cumsum(resoP2)\n\n\n\n  resoI2<-resIst.clust[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2.clust<-1/sqrt(N )*cumsum(resoI2)\n\n  resoP2<-resPst.clust[orP]\n  t01P<- estP\n  for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n    ig<-which(round(t01P[orP],10)==round(ii,10))\n    resoP2[ig]<-sum(resoP2[ig])/length(ig)\n  }\n\n  WP2.clust<-1/sqrt(N )*cumsum(resoP2)\n\n\n\n  ####start sim/sign/permuted proces\n\n  ###simulation, Pan approach\n\n\n  WsP2.ind<- WsI2.ind <-list()\n\n  WsP2.clust<- WsI2.clust <-list()\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Simulation Pan: \",iiii,sep=\"\"))\n\n\n\n\n    newres<-NA\n    for (gg in 1:N){\n      smp<-rnorm(1)\n      newres<-c(newres, ( (resP*smp)[id==gg]))\n    }\n\n    newres<-newres[-1]\n\n\n\n    ##prvi del procesa\n\n    prvi.del.p.ind<-prvi.del.ind<-prvi.del.p.clust<-prvi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      prvi.del.ind<-c(prvi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%(newres[id==gg]))\n      prvi.del.clust<-c(prvi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%(newres[id==gg]))\n\n      prvi.del.p.clust<-c(prvi.del.p.clust,S.i[[gg]]%*%(newres[id==gg]))\n      prvi.del.p.ind<-c(prvi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n    }\n\n    prvi.del.ind<-prvi.del.ind[-1]\n    prvi.del.p.ind<-prvi.del.p.ind[-1]\n\n    prvi.del.clust<-prvi.del.clust[-1]\n    prvi.del.p.clust<-prvi.del.p.clust[-1]\n\n    prvi.del.o<-prvi.del.ind[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iind<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.o<-prvi.del.clust[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iclust<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.op<-prvi.del.p.ind[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipind<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    prvi.del.op<-prvi.del.p.clust[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipclust<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    dva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\n    for (gg  in 1:N){\n\n      if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n    }\n\n    drugi.del.p.ind<-drugi.del.ind<-drugi.del.p.clust<-drugi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      drugi.del.ind<-c(drugi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.clust<-c(drugi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n      drugi.del.p.clust<-c(drugi.del.p.clust,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.p.ind<-c(drugi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n    }\n\n    drugi.del.ind<-drugi.del.ind[-1]\n    drugi.del.p.ind<-drugi.del.p.ind[-1]\n\n    drugi.del.clust<-drugi.del.clust[-1]\n    drugi.del.p.clust<-drugi.del.p.clust[-1]\n\n    drugi.del.o<-drugi.del.ind[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.ind[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIind<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpind<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    drugi.del.o<-drugi.del.clust[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.clust[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIclust<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpclust<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    WsI2.ind[[iiii]]<-Iind-IIind\n    WsP2.ind[[iiii]]<-Ipind-IIpind\n\n    WsI2.clust[[iiii]]<-Iclust-IIclust\n    WsP2.clust[[iiii]]<-Ipclust-IIpclust\n\n\n\n\n\n  }\n\n  res.sim.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n\n  res.sim.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n###simulation, our approach\n\n\n\n\n  WsP2.ind<- WsI2.ind <-list()\n\n  WsP2.clust<- WsI2.clust <-list()\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Simulation: \",iiii,sep=\"\"))\n\n\n\n    smp<-rnorm(nrow(x))\n\n    newres<-NA\n    for (gg in 1:N){\n      newres<-c(newres, V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n    }\n\n    newres<-newres[-1]\n\n\n\n    ##prvi del procesa\n\n    prvi.del.p.ind<-prvi.del.ind<-prvi.del.p.clust<-prvi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      prvi.del.ind<-c(prvi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%(newres[id==gg]))\n      prvi.del.clust<-c(prvi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%(newres[id==gg]))\n\n      prvi.del.p.clust<-c(prvi.del.p.clust,S.i[[gg]]%*%(newres[id==gg]))\n      prvi.del.p.ind<-c(prvi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))\n\n    }\n\n    prvi.del.ind<-prvi.del.ind[-1]\n    prvi.del.p.ind<-prvi.del.p.ind[-1]\n\n    prvi.del.clust<-prvi.del.clust[-1]\n    prvi.del.p.clust<-prvi.del.p.clust[-1]\n\n    prvi.del.o<-prvi.del.ind[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iind<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.o<-prvi.del.clust[orI]\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)\n    }\n\n\n    Iclust<-1/sqrt(N)*cumsum(prvi.del.o)\n\n    prvi.del.op<-prvi.del.p.ind[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipind<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    prvi.del.op<-prvi.del.p.clust[orP]\n\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)\n    }\n\n\n    Ipclust<-1/sqrt(N)*cumsum(prvi.del.op)\n\n    dva.1<-matrix(0,ncol=1,nrow=ncol(x))\n\n    for (gg  in 1:N){\n\n      if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])\n\n    }\n\n    drugi.del.p.ind<-drugi.del.ind<-drugi.del.p.clust<-drugi.del.clust<-NA\n\n    for (gg in 1:N){\n\n      drugi.del.ind<-c(drugi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.clust<-c(drugi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n      drugi.del.p.clust<-c(drugi.del.p.clust,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n      drugi.del.p.ind<-c(drugi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)\n\n\n    }\n\n    drugi.del.ind<-drugi.del.ind[-1]\n    drugi.del.p.ind<-drugi.del.p.ind[-1]\n\n    drugi.del.clust<-drugi.del.clust[-1]\n    drugi.del.p.clust<-drugi.del.p.clust[-1]\n\n    drugi.del.o<-drugi.del.ind[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.ind[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIind<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpind<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    drugi.del.o<-drugi.del.clust[orI]\n\n\n    t01<- estI\n\n    for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n      ig<-which(round(t01[orI],10)==round(ii,10))\n      drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)\n    }\n\n\n    drugi.del.op<-drugi.del.p.clust[orP]\n    t01P<- estP\n    for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){\n      ig<-which(round(t01P[orP],10)==round(ii,10))\n      drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)\n    }\n\n\n\n    IIclust<-1/sqrt( N)*cumsum(drugi.del.o)\n    IIpclust<-1/sqrt( N)*cumsum(drugi.del.op)\n\n    WsI2.ind[[iiii]]<-Iind-IIind\n    WsP2.ind[[iiii]]<-Ipind-IIpind\n\n    WsI2.clust[[iiii]]<-Iclust-IIclust\n    WsP2.clust[[iiii]]<-Ipclust-IIpclust\n\n\n\n\n\n  }\n\n  res.sim.our.ind<-c(\n    p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n    p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n    p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n    p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n  )\n\n  res.sim.our.clust<-c(\n    p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n    p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n    p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n    p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n  )\n\n\n\n\n\n\n\n\n      WsP2.ind<- WsI2.ind <-list()\n      WsP2.clust<- WsI2.clust <-list()\n\n      for (iiii in 1:M){\n\n        if (verbose) print(paste(\"Sign-flip: \",iiii,sep=\"\"))\n\n        smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n        ys<-NA\n        for (gg in 1:N){\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n        }\n        ys<-ys[-1]\n\n        datas<-fit$data\n        datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n        fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n        sim.proc<-get.sim.proc.fast(fits, std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,\n                               n=n,N=N,x=x,ZZ=ZZ,id=id)\n\n        WsI2.ind[[iiii]]<-sim.proc[[1]]\n        WsP2.ind[[iiii]]<-sim.proc[[2]]\n\n\n        WsI2.clust[[iiii]]<-sim.proc[[3]]\n        WsP2.clust[[iiii]]<-sim.proc[[4]]\n\n\n      } #end for\n\n\n      res.sign.ind<-c(\n        p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n        p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n        p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n        p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n      )\n      res.sign.clust<-c(\n        p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n        p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n        p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n        p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n      )\n\n\n      WsP2.ind<- WsI2.ind <-list()\n      WsP2.clust<- WsI2.clust <-list()\n\n\n      for (iiii in 1:M){\n\n        if (verbose) print(paste(\"Permutation: \",iiii,sep=\"\"))\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n        datas<-fit$data\n        datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n        fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n        sim.proc<-get.sim.proc.fast(fits, std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,\n                                    n=n,N=N,x=x,ZZ=ZZ,id=id)\n\n        WsI2.ind[[iiii]]<-sim.proc[[1]]\n        WsP2.ind[[iiii]]<-sim.proc[[2]]\n\n\n        WsI2.clust[[iiii]]<-sim.proc[[3]]\n        WsP2.clust[[iiii]]<-sim.proc[[4]]\n\n      } #end for\n\n\n      res.perm.ind<-c(\n        p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),\n        p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),\n\n        p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),\n        p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )\n      )\n      res.perm.clust<-c(\n        p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),\n        p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),\n\n        p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),\n        p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )\n      )\n\n\n  res.ind<-c(res.sim.ind,res.sim.our.ind, res.sign.ind,res.perm.ind)\n  res.clust<-c(res.sim.clust,res.sim.our.clust, res.sign.clust,res.perm.clust)\n\n  names(res.ind)<-names(res.clust)<-c(\n  paste(\"Sim\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n  paste(\"SimOur\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n  paste(\"Sign\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\"),\n  paste(\"Perm\",c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\"),sep=\":\")\n)\n\n resm.ind<-matrix(res.ind,ncol=4,byrow=T)\n resm.clust<-matrix(res.clust,ncol=4,byrow=T)\n\n\n colnames(resm.ind)<-colnames(resm.clust)<-c(\"O.KS\",\"O.CvM\",\"F.KS\",\"F.CvM\")\n rownames(resm.ind)<-rownames(resm.clust)<-c(\"Simulation.Pan\",\"Simulation\",\"sign.flip\",\"permutation\")\n list(results.ind=res.ind,results.matrix.ind=resm.ind,results.clust=res.clust,results.matrix.clust=resm.clust)\n} #end of function\n\n\n\n\n\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\n\nproci<-function(i,res,est){\n  or<-order(est[[i]])\n  WI<-cumsum( res[[i]][or] )\n  t01P<- est[[i]]\n  for (ii in as.numeric(names(table(t01P[or]))[which(table(t01P[or])>1)])){\n    ig<-which(round(t01P[or],10)==round(ii,10))\n    WI[ig]<-sum(WI[ig])/length(ig)\n  }\n  WI\n}\n\n#' Internal function\n#' @keywords internal\n\nmakeO<-function(res,est,id){\n\n  res.s<-split(res,id)\n  est.s<-split(est,id)\n\n\n  lapply(unique(id),proci,res.s,est.s)\n\n\n}\n\n\n#' Internal function\n#' @keywords internal\n\n\nget.sim.proc.i<-function(fit, residuals ,std.type ,use.correction.for.imbalance , order.by.original ,  or.original.fitted.P ,  original.fitted.P ,n,N,x,ZZ,id ){\n\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n\n  if (order.by.original==TRUE)  estP<-original.fitted.P else  estP<-fitted(fit,level=0)\n\n\n  if (order.by.original==TRUE)  orP<-or.original.fitted.P  else orP<-order(estP)\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n\n\n  V.ii.inv<-list()\n\n\n  if (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n\n\n\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n\n\n\n\n    if (std.type==2) Si<-V.ii.inv[[gg]] else Si<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) Si<-Si/sqrt(n[gg])\n\n\n\n    resPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-Si%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst<-c(resPst,resPMpC2P)\n\n  }\n\n\n\n  resPst<-resPst[-1]\n\n\n\n  WP2<-makeO(resPst,estP,id)\n  WP2\n\n\n\n}\n\n\n\n\n\n#######main function\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process for O and John's idea. Not well tested!\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process. Possible values are \\code{\"individual\"} and \\code{\"cluster\"} for \\textit{individual} and \\textit{cluster-speciffic} residuals, respectively.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param type How to obtain the processes $W^m$. Possible values are  \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param order.by.original Logical. Should the residuals in the the processes $W^m$ be ordered by the original fitted values? Defaults to \\code{FALSE}.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @return An object of class \\code{\"gofLMM\"} for which \\code{plot} and \\code{summary} functions are available.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm.pan}}, \\code{\\link{gof.lmm.sim}}\n#' @export\n#' @examples\n#' # simulate some data:\n#' N=50\n#' set.seed(1)\n#' n<-floor(runif(N,min=1,max=15)) #imbalanced\n#' betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE\n#' norm.eps<-FALSE\n#' shape=0.5\n#' scale=1\n#' norm.re.intercept<-FALSE\n#' shape.re.intercept=0.5\n#' scale.re.intercept=1\n#' norm.re.slope<-FALSE\n#' shape.re.slope=0.5\n#' scale.re.slope=1\n#' sim.re.slope=TRUE\n#' over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data\n#' omit.important.predictor=FALSE\n#' yy<-NA\n#' x22<-NA\n#' id<-NA\n#' x1<-NA\n#' for (gg in 1:N){\n#'\n#'   id<-c(id,rep(gg,each=n[gg]))\n#'   x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])\n#'   x1<-c(x1,x11)\n#'\n#'   if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept\n#'\n#'   b<-rep(re.int,each=n[gg])\n#'\n#'   if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope\n#'\n#'   b2<-rep(re.slope,each=n[gg])\n#'   x2<-1:n[gg]\n#'   x4<-runif(n[gg])\n#'\n#'   if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale\n#'\n#'   if (sim.re.slope==TRUE) {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4\n#'   } else {\n#'     if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4\n#'   }\n#'   yy<-c(yy,y)\n#'  x22<-c(x22,x2)\n#' }\n#' yy<-yy[-1]\n#' x22<-x22[-1]\n#' x1<-x1[-1]\n#' id<-id[-1]\n#' x4<-runif(sum(n))\n#' aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)\n#' library(nlme)\n#' fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~1|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' fit.gof<-gof.lmm.O.type2(fit,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,type= \"permutation\" ,M=100,order.by.original=FALSE,verbose=TRUE)\n#' fit.gof$KS\n#' fit2<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' fit.gof2<-gof.lmm.O.type2(fit2,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,type= \"permutation\" ,M=100,order.by.original=FALSE,verbose=TRUE)\n#' fit.gof2$KS\n#' fit3<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x1|ptnt,control=lmeControl( returnObject = TRUE),method=\"REML\" )\n#' fit.gof3<-gof.lmm.O.type2(fit3,residuals= \"individual\" ,std.type=2,use.correction.for.imbalance=FALSE,type= \"permutation\" ,M=100,order.by.original=FALSE,verbose=TRUE)\n#' fit.gof3$KS\n\n\n\n\n\n\ngof.lmm.O.type2<-function(fit,residuals=c(\"individual\",\"cluster\"),std.type=c(1,2),use.correction.for.imbalance=FALSE,type=c(\"sign.flip\",\"permutation\"),M=100,order.by.original=FALSE,verbose=FALSE){\n\n  ####checks, warnings\n\n  if (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\n  if (verbose) cat(\"Using  \\\"verbose=FALSE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\n\n\n  ####preliminaries\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n  id.c<-NA\n  for (ii in 1:N){\n    id.c<-c(id.c,rep(ii,n[ii]))\n  }\n  id.c<-id.c[-1]\n\n  if (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estP<-fitted(fit,level=0)\n\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n     if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  if (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n  respermute<-NA\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n\n\n    resPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst<-c(resPst,resPMpC2P)\n\n  }\n\n  respermute<-respermute[-1]\n  resPst<-resPst[-1]\n\n\n  WI2<-makeO(resPst,estP,id)\n\n\n  ks<-unlist(lapply(WI2,KS))\n\n  cvm<-unlist(lapply(WI2,CvM))\n\n\n\n  ksi<-cvmi <-matrix(NA,ncol=length(ks),nrow=M)\n\nWSI<-list()\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n    if (type==\"sign.flip\") {\n      smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n      ys<-NA\n      for (gg in 1:N){\n        ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n      }\n      ys<-ys[-1]} else {\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n      }\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.i(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,or.original.fitted.P=orP,original.fitted.P=estP,n=n,N=N,x=x,ZZ=ZZ,id=id)\n\n    ksi[iiii,]<-unlist(lapply(sim.proc,KS))\n    cvmi[iiii,]<-unlist(lapply(sim.proc,CvM))\nWSI[[iiii]]<-unlist(sim.proc)\n\n\n  } #end for\n\n\n\n  pg.ks<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),ks,ksi  ))\n  pg.cvm<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),cvm,cvmi  ))\n\n  ts.ks<--2*sum(log(pg.ks))\n  ts.cvm<--2*sum(log(pg.cvm))\n\n  p.ks<-pchisq( ts.ks, df=  2*N,lower.tail=F )\n  p.cvm<-pchisq( ts.cvm, df=  2*N,lower.tail=F )\n\n\n  res<-list(KS=p.ks,CvM=p.cvm,WI=unlist(WI2),WIm=WSI)\n  res\n\n\n} #end of function\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\n\n\n\ngof.lmm.O.type2.i<-function(fit,residuals ,std.type,use.correction.for.imbalance,type,M,order.by.original,id,N,n,ZZ,x){\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estP<-fitted(fit,level=0)\n\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  if (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n  respermute<-NA\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n\n\n    resPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst<-c(resPst,resPMpC2P)\n\n  }\n\n  respermute<-respermute[-1]\n  resPst<-resPst[-1]\n\n\n  WI2<-makeO(resPst,estP,id)\n\n\n  ks<-unlist(lapply(WI2,KS))\n\n  cvm<-unlist(lapply(WI2,CvM))\n\n\n\n  ksi<-cvmi <-matrix(NA,ncol=length(ks),nrow=M)\n\n  WSI<-list()\n  for (iiii in 1:M){\n\n     if (type==\"sign.flip\") {\n      smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n      ys<-NA\n      for (gg in 1:N){\n        ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n      }\n      ys<-ys[-1]} else {\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n      }\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.i(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,or.original.fitted.P=orP,original.fitted.P=estP,n=n,N=N,x=x,ZZ=ZZ,id=id)\n\n    ksi[iiii,]<-unlist(lapply(sim.proc,KS))\n    cvmi[iiii,]<-unlist(lapply(sim.proc,CvM))\n    WSI[[iiii]]<-unlist(sim.proc)\n\n\n  } #end for\n\n\n\n  pg.ks<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),ks,ksi  ))\n  pg.cvm<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),cvm,cvmi  ))\n\n  ts.ks<--2*sum(log(pg.ks))\n  ts.cvm<--2*sum(log(pg.cvm))\n\n  c(ts.ks,ts.cvm)\n\n\n} #end of function\n\n\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process for Oi and John's idea using full parametric bootstrap to obtain p-values. Not well tested!\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process. Possible values are \\code{\"individual\"} and \\code{\"cluster\"} for \\textit{individual} and \\textit{cluster-speciffic} residuals, respectively.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param type How to obtain the processes $W^m$. Possible values are  \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param B Number of boot replications. Defaults to \\code{100}.\n#' @param order.by.original Logical. Should the residuals in the the processes $W^m$ be ordered by the original fitted values? Defaults to \\code{FALSE}.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @return An object of class \\code{\"gofLMM\"} for which \\code{plot} and \\code{summary} functions are available.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm.pan}}, \\code{\\link{gof.lmm.sim}}\n#' @export\n\n\ngof.lmm.O.type2.boot<-function(fit,residuals=c(\"individual\",\"cluster\"),std.type=c(1,2),use.correction.for.imbalance=FALSE,type=c(\"sign.flip\",\"permutation\"),M=100,B=100,order.by.original=FALSE,verbose=FALSE){\n\n  ####checks, warnings\n\n  if (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\n  if (verbose) cat(\"Using  \\\"verbose=FALSE \\\" slows down the algorithm, but it might feel faster. Get some snack as this might take a while. \\n\")\n\n\n\n  ####preliminaries\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n  id.c<-NA\n  for (ii in 1:N){\n    id.c<-c(id.c,rep(ii,n[ii]))\n  }\n  id.c<-id.c[-1]\n\n  if (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estP<-fitted(fit,level=0)\n\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n  }\n\n  H.i<-solve(H)\n\n\n  if (residuals==\"individual\") res.i.c2<-resI else res.i.c2<-resP\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n  respermute<-NA\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n\n\n    resPMpCP<-matrix(res.i.c2[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2P<-S.i[[gg]]%*%resPMpCP\n    resPMpC2P<-resPMpC2P\n\n    resPst<-c(resPst,resPMpC2P)\n\n  }\n\n  respermute<-respermute[-1]\n  resPst<-resPst[-1]\n\n\n  WI2<-makeO(resPst,estP,id)\n\n\n  ks<-unlist(lapply(WI2,KS))\n\n  cvm<-unlist(lapply(WI2,CvM))\n\n\n\n  ksi<-cvmi <-matrix(NA,ncol=length(ks),nrow=M)\n\n  WSI<-list()\n  for (iiii in 1:M){\n\n     if (type==\"sign.flip\") {\n      smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n      ys<-NA\n      for (gg in 1:N){\n        ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n      }\n      ys<-ys[-1]} else {\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n      }\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.i(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,or.original.fitted.P=orP,original.fitted.P=estP,n=n,N=N,x=x,ZZ=ZZ,id=id)\n\n    ksi[iiii,]<-unlist(lapply(sim.proc,KS))\n    cvmi[iiii,]<-unlist(lapply(sim.proc,CvM))\n    WSI[[iiii]]<-unlist(sim.proc)\n\n\n  } #end for\n\n\n\n  pg.ks<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),ks,ksi  ))\n  pg.cvm<-unlist(lapply(1:N,function(i,x,y) p.val(x[[i]],y[,i]),cvm,cvmi  ))\n\n  ts.ks<--2*sum(log(pg.ks))\n  ts.cvm<--2*sum(log(pg.cvm))\n\n  res.boot<-matrix(NA,ncol=2,nrow=B)\n\n  for (ii in 1:B){\n    if (verbose) print(paste(\"Bootstrap Iteration: \",ii,sep=\"\"))\n\nys<-NA\n    for (jj in 1:N){\n     mui<-x[id==jj,]%*%matrix(fixef(fit),ncol=1)\n     vari<-Z[[jj]]%*%D%*%t(Z[[jj]])+sigma.est*diag(rep(1,n[jj]))\n     ys<-c(ys,rmvnorm(1,mui,vari))\n    }\nys<-ys[-1]\ndatas<-fit$data\ndatas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\nfits<-suppressWarnings(update(fit,data=datas))\nres.boot[ii,]<-gof.lmm.O.type2.i(fit=fits,residuals=residuals ,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,type=type,M=M,\n                  order.by.original=order.by.original,id=id,N=N,n=n,ZZ=ZZ,x=x)\n\n\n  }\n\n\np.ks<-p.val(ts.ks,res.boot[,1])\np.cvm<-p.val(ts.cvm,res.boot[,2])\n\nlist(p.ks=p.ks,p.cvm=p.cvm,ts.ks=ts.ks,ts.cvm=ts.cvm)\n\n} #end of function\n\n\n\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\nget.sim.proc.O.test<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,order.by.original,n,N,x,ZZ,id, est.original,or.original ){\n\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\nestP<-fitted(fit,level=0)\n\norI<-order(estI)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\nXi<-list()\nZb<-list()\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\nif (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)\n\n}\n\nH.i<-solve(H)\n\n\n#A<-list()\n#B<-list()\n\nres.i.c<-resI\n\n#mm=0\n#for (gg in 1:N){\n#  for (jj in 1:N){\n#    mm=mm+1\n\n\n#    if (jj==gg){\n\n#      zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])\n#      cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])\n\n      ###A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n      ###B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n#      vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz\n\n#      A[[mm]]<-sigma.est*vzd\n#      B[[mm]]<-zdz %*%vzd\n#    } else {\n\n#      zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])\n#      zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])\n#      cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])\n\n      #####A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n      ####B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n\n#      vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj\n\n#      A[[mm]]<--sigma.est*vzdj\n#      B[[mm]]<--zdzg %*%vzdj\n\n\n#    }\n\n#  }}\n\n#aa<-bb<-list()\n#mm=0\n\n#for (gg in 1:N){\n\n#for (jj in 1:N){\n#mm=mm+1\n#if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])\n#if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])\n#}}\n\n#for (gg in 1:N){\n#if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])\n#if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])\n\n#}\n\n\nNN<-nrow(x)\n\nVd<-matrix(0,NN,NN)\nfor (i in 1:N){\n\n  is<-which(id==i)\n  Vd[ is,is]<-V[[i]]\n\n}\n\nIN<-diag(rep(1,NN))\nVdi<-solve(Vd)\nsVdi<-sigma.est*Vdi\np1<-(IN-sVdi)\np2<-( Vd-x%*%H.i%*%t(x)   )%*%p1\nAA<-sVdi%*%p2\nBB<-p1%*%p2\nZb<-matrix(estI-estP,ncol=1)\n\n\n#if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb\nif (residuals==\"individual\") res.i.c<-resI-AA%*%my.MP(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%my.MP(BB)%*%Zb\n\n\n\n\nV.ii.inv<-list()\nV.ii<-list()\nS.i<-list()\n\n\n\n\nresIst<-NA\n\n\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\nV.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n\n\nif (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\nresPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2<-S.i[[gg]]%*%resPMpC\nresPMpC2<-resPMpC2\n\nresIst<-c(resIst,resPMpC2)\n\n\n}\n\n\n\nresIst<-resIst[-1]\n\n\nif (order.by.original==TRUE) {estI=est.original  ; orI= or.original }\n\nresoI2<-resIst[orI]\n t01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\n\nWI2<-1/sqrt(N )*cumsum(resoI2)\n\nlist(WI2,estI)\n\n}\n\n\n#' Internal function\n#' @keywords internal\n\n\nmy.MP <- function(A, eps=10^(-8))   {\n\n PV<-eigen(A,symmetric=T)\n V0<-IV<-PV$values\n IV[abs(V0)>eps]<-1/V0[abs(V0)>eps]\n IV[abs(V0)<=eps]<-0\n Ainv<-PV$vectors%*%(IV*t(PV$vectors  )  )\nreturn(Ainv)\n\n\n}\n\n\n\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process for O using non-diagonal blocked matrices A and B. An error occurs often when calculating the MP generalized inverse of the matrix B, which is due to Lapack routine. Can be very slow and inefficient when n and ni are large. Now I replaced the ginv() from MASS by my.MP which is the MP inverse as suggested by Demidenko p.51 but the error persits, so it must occur in the fitting of lme.\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param type How to obtain the processes $W^m$. Possible values are  \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param order.by.original Order the residuals by original fitted values? Defaults to FALSE.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm}}\n#' @export\n\n\ngof.lmm.O.test<-function(fit,residuals=\"individual\",std.type=c(1,2),use.correction.for.imbalance=FALSE,type=c(\"sign.flip\",\"permutation\"),M=100,order.by.original=FALSE,verbose=FALSE){\n\n####checks, warnings\n\nif (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\nif (verbose) cat(\"Using  \\\"verbose=TRUE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\n\n\n####preliminaries\n\n\n\n\nid<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\nN<-length(unique(id))\nn<-table(id)\n\n\nid.c<-NA\nfor (ii in 1:N){\nid.c<-c(id.c,rep(ii,n[ii]))\n}\nid.c<-id.c[-1]\n\nif (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\nx<-model.matrix(fit, data=fit$data   )\n\nZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n###start gof\n\n\n\nresI<-residuals(fit, level = 1  )\n\n\nresP<-residuals(fit, level = 0  )\n\nestI<-fitted(fit,level=1)\n estP<-fitted(fit,level=0)\n\norI<-order(estI)\norP<-order(estP)\n\n\n\nvc<-VarCorr(fit)\nsigma.est<-as.numeric(vc[nrow(vc),1])\n\nD<-getVarCov(fit)\n\nbeta.f<-fixef(fit)\n\nV<-list()\nV.i<-list()\nZ<-list()\nXi<-list()\nZb<-list()\nH<-matrix(0,ncol=ncol(x),nrow=ncol(x))\nfor (gg in 1:N){\nif (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\nif (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\nI<-diag(rep(1),n[[gg]])\nV[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\nV.i[[gg]]<-V[[gg]]%^%(-1)\nif (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\nif (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)\n\n}\n\nH.i<-solve(H)\n\n\n#A<-list()\n#B<-list()\n\nres.i.c<-resI\n\n#mm=0\n#for (gg in 1:N){\n#for (jj in 1:N){\n#mm=mm+1\n\n\n#if (jj==gg){\n\n # zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])\n#  cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])\n\n      ###A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n      ####B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n # vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz\n\n  #A[[mm]]<-sigma.est*vzd\n  #B[[mm]]<-zdz %*%vzd\n  #} else {\n\n   # zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])\n  #  zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])\n  #  cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])\n\n      ####A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n      ####B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n\n#vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj\n\n#A[[mm]]<--sigma.est*vzdj\n#B[[mm]]<--zdzg %*%vzdj\n\n\n#}\n\n#}}\n\n#aa<-bb<-list()\n#mm=0\n\n#for (gg in 1:N){\n\n#for (jj in 1:N){\n#mm=mm+1\n#if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])\n#if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])\n#}}\n\n#for (gg in 1:N){\n#if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])\n#if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])\n\n#}\n\nNN<-nrow(x)\n\nVd<-Vdi<-matrix(0,NN,NN)\nfor (i in 1:N){\n\n  is<-which(id==i)\n  Vd[ is,is]<-V[[i]]\n  Vdi[ is,is]<-V.i[[i]]\n}\n\nIN<-diag(rep(1,NN))\n#Vdi<-solve(Vd)\nsVdi<-sigma.est*Vdi\np1<-(IN-sVdi)\np2<-( Vd-x%*%H.i%*%t(x)   )%*%p1\nAA<-sVdi%*%p2\nBB<-p1%*%p2\n\n\n\n\n\nZb<-matrix(estI-estP,ncol=1)\n\n#if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb\nif (residuals==\"individual\") res.i.c<-resI-AA%*%my.MP(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%my.MP(BB)%*%Zb\n\n\n\nV.ii.inv<-list()\nV.ii<-list()\nS.i<-list()\n\n\nrespermute<-NA\nresIst<-NA\nresPst<-NA\nfor (gg in 1:N){\nI<-diag(rep(1,n[gg]))\n\nV.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\nV.ii[[gg]]<-V[[gg]]%^%(0.5)\n\nresPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMp2<-V.ii.inv[[gg]]%*%resPMp\n\nrespermute<-c(respermute,resPMp2)\n\nif (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\nif (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\nresPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\nresPMpC2<-S.i[[gg]]%*%resPMpC\nresPMpC2<-resPMpC2\n\nresIst<-c(resIst,resPMpC2)\n\n\n}\n\nrespermute<-respermute[-1]\nresIst<-resIst[-1]\n\n\nresoI2<-resIst[orI]\n t01<- estI\n\nfor (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\nig<-which(round(t01[orI],10)==round(ii,10))\nresoI2[ig]<-sum(resoI2[ig])/length(ig)\n}\n\nWI2<-1/sqrt(N )*cumsum(resoI2)\n\n WsI2 <-list()\n estIm<-list()\n\n\n\n\niiii=0\n\nwhile (iiii < M){\n\n\nif (verbose) print(paste(\"Iteration: \",iiii+1,sep=\"\"))\n\nif (type==\"sign.flip\"){\n\nsmp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\nys<-NA\nfor (gg in 1:N){\nys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n}\nys<-ys[-1] } else {\n\nys<-NA\nfor (gg in 1:N){\n\nif (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\nys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n}\nys<-ys[-1]\n\n}\n\ndatas<-fit$data\ndatas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\nfits<-suppressWarnings(update(fit,data=datas))\n\n\n\n#sim.proc<-try(get.sim.proc.O.test(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,n=n,N=N,x=x,ZZ=ZZ,id=id, est.original=estI,or.original=orI),silent = TRUE)\n\n#if (class(sim.proc)!=\"try-error\"){\n # iiii=iiii+1\n# WsI2[[iiii]]<-sim.proc[[1]]\n#estIm[[iiii]]<-sim.proc[[2]]\n\n\n#}\n\nsim.proc<-get.sim.proc.O.test(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,n=n,N=N,x=x,ZZ=ZZ,id=id, est.original=estI,or.original=orI)\niiii=iiii+1\nWsI2[[iiii]]<-sim.proc[[1]]\nestIm[[iiii]]<-sim.proc[[2]]\n\n\n} #end while\n\n\n\n\n\n\n\nres<-list(O=WI2,F=NULL,Om=WsI2,Fm=NULL,Fs=NULL,Fsm=NULL,predO=estI,predOm=estIm,predF=NULL,predFm=NULL,predFs=NULL,predFsm=NULL)\nclass(res)<-\"gofLMM\"\nres\n\n\n} #end of function\n\n\nsummary.gofLMM.testO<-function(object){\n\n  O.s<-test.stat.p.val(object$O,object$Om)\n\n\n  res<-O.s\n\n  rownames(res)<-c(paste(\"O\",rownames(res)[1:2],sep=\":\"))\n  res\n\n}\n\n\n\n\n\n\n#' Internal function\n#' @keywords internal\n\nget.sim.proc.O.test.2<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,order.by.original,  n,N,x,ZZ,id, orest,ororder ){\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n\n  }\n\n  H.i<-solve(H)\n\n\n  Zb<-matrix(estI-estP,ncol=1)\n\n  res.i.c<-resI\n\n  for (gg in 1:N){\n    A<-sigma.est*V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    B<-Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n    res.i.c[id==gg]<-resI[id==gg]-A%*%ginv(B)%*%Zb[id==gg]\n\n  }\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n\n\n\n  resIst<-NA\n\n\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst<-c(resIst,resPMpC2)\n\n\n  }\n\n\n\n  resIst<-resIst[-1]\n if (order.by.original==TRUE) {estI=orest; orI=ororder}\n\n  resoI2<-resIst[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2<-1/sqrt(N )*cumsum(resoI2)\n\n  list(WI2,estI)\n\n}\n\n\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process for O using a limit expressions for diagonal blocked matrices A and B.\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process. Currently implemented only for \\code{\"individual\"} for \\textit{individual} residuals.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param type How to obtain the processes $W^m$. Possible values are  \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param order.by.original Order the residuals by the original fitted values. Deafults to FALSE.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm}}\n#' @export\n\ngof.lmm.O.test.2<-function(fit,residuals=\"individual\",std.type=c(1,2),use.correction.for.imbalance=FALSE,type=c(\"sign.flip\",\"permutation\"),M=100,order.by.original=FALSE,verbose=FALSE){\n\n  ####checks, warnings\n\n  if (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\n  if (verbose) cat(\"Using  \\\"verbose=FALSE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\n\n\n  ####preliminaries\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n  id.c<-NA\n  for (ii in 1:N){\n    id.c<-c(id.c,rep(ii,n[ii]))\n  }\n  id.c<-id.c[-1]\n\n  if (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n\n  }\n\n  H.i<-solve(H)\n\n\n  Zb<-matrix(estI-estP,ncol=1)\n\n  res.i.c<-resI\n\n    for (gg in 1:N){\n          A<-sigma.est*V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n        B<-Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n        res.i.c[id==gg]<-resI[id==gg]-A%*%ginv(B)%*%Zb[id==gg]\n\n    }\n\n\n\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n\n  respermute<-NA\n  resIst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst<-c(resIst,resPMpC2)\n\n\n  }\n\n  respermute<-respermute[-1]\n  resIst<-resIst[-1]\n\n\n  resoI2<-resIst[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2<-1/sqrt(N )*cumsum(resoI2)\n\n  WsI2 <-list()\n  estIm<-list()\n\n\n\n\n\n\n  for (iiii in 1:M){\n\n    if (verbose) print(paste(\"Iteration: \",iiii+1,sep=\"\"))\n\n    if (type==\"sign.flip\"){\n\n      smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n      ys<-NA\n      for (gg in 1:N){\n        ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n      }\n      ys<-ys[-1] } else {\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n      }\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-get.sim.proc.O.test.2(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,order.by.original=order.by.original,n=n,N=N,x=x,ZZ=ZZ,id=id,orest=estI,ororder=orI)\n\n    WsI2[[iiii]]<-sim.proc[[1]]\n    estIm[[iiii]]<-sim.proc[[2]]\n\n\n\n  } #end for\n\n\n\n\n\n\n\n  res<-list(O=WI2,F=NULL,Om=WsI2,Fm=NULL,Fs=NULL,Fsm=NULL,predO=estI,predOm=estIm,predF=NULL,predFm=NULL,predFs=NULL,predFsm=NULL)\n  class(res)<-\"gofLMM\"\n  res\n\n\n} #end of function\n\n\n\n\n\n###when you use SF and order by original you do not have to reestimate A and B, this is what I tried here\n\n\n\n#' Internal function\n#' @keywords internal\n\nget.sim.proc.O.test.type2<-function(fit, residuals ,std.type ,use.correction.for.imbalance ,n,N,x,ZZ,id, est.original,or.original ,A,B){\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n  Xi<-list()\n  Zb<-list()\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n    if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)\n\n  }\n\n  H.i<-solve(H)\n\n\n  AA<-A\n  BB<-B\n  Zb<-matrix(estI-estP,ncol=1)\n\n\n  if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb\n  #if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%estI else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%estI\n\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n\n\n\n  resIst<-NA\n\n\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst<-c(resIst,resPMpC2)\n\n\n  }\n\n\n\n  resIst<-resIst[-1]\n\n\n  estI=est.original\n  orI= or.original\n\n  resoI2<-resIst[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2<-1/sqrt(N )*cumsum(resoI2)\n\n  list(WI2,estI)\n\n}\n\n\n\n\n#' Goodness-of fit test for LMM\n#'\n#' Goodness-of fit test based on cumulative sum stochastic process for O using non-diagonal blocked matrices A and B. I am not reestimating A and B and always ordering by the original fitted values!\n\n#'\n#' @param fit The result of a call to \\code{\"nlme\"}. The model must be fitted with \\code{control=lmeControl( returnObject = TRUE)} and \\code{keep.data=TRUE}. An error message is returned otherwise. ID variable must be numeric and ordered from 1:N ! Canno't use transofrmations of the outcome variable directly in the formula i.e. lme(sqrt(y)~x) will return p=1!\n#' @param residuals Residuals to be used when constructing the process.\n#' @param std.type Type of standardization to be used for the residuals when constructing the process.\n#' Currently implemeneted options are \\code{1} and \\code{2} for $S_i=\\hat\\sigma^{-1/2}I_{n_i}$ and $S_i=\\hat{V}_i^{-1/2}$.\n#' @param use.correction.for.imbalance Logical. use $n_i^{-1/2} S_i$ when standardizing the residuals. Defaults to \\code{FALSE}.\n#' @param type How to obtain the processes $W^m$. Possible values are  \\code{\"sign.flip\"} for the sign-flipping approach and \\code{\"permutation\"} for the permutation approach.\n#' @param M Number of random simulations/sign-flipps/permutations. Defaults to \\code{100}.\n#' @param verbose Logical. Print the current status of the test. Can slow down the algorithm, but it can make it feel faster. Defaults to \\code{FALSE}.\n#' @author Rok Blagus, \\email{rok.blagus@@mf.uni-lj.si}\n#' @seealso \\code{\\link{gof.lmm}}\n#' @export\n\n\ngof.lmm.O.test.type2<-function(fit,residuals=\"individual\",std.type=c(1,2),use.correction.for.imbalance=FALSE,type=c(\"sign.flip\",\"permutation\"),M=100,verbose=FALSE){\n\n  ####checks, warnings\n\n  if (is.null(fit$data)) stop(\"Model was fitted with keep.data=FALSE. Use keep.data=TRUE.\")\n\n  if (verbose) cat(\"Using  \\\"verbose=TRUE \\\" slows down the algorithm, but it might feel faster. \\n\")\n\n\n\n  ####preliminaries\n\n\n\n\n  id<-fit$data[,names(formula(fit$modelStruct$reStr))]\n\n  N<-length(unique(id))\n  n<-table(id)\n\n\n  id.c<-NA\n  for (ii in 1:N){\n    id.c<-c(id.c,rep(ii,n[ii]))\n  }\n  id.c<-id.c[-1]\n\n  if (sum(as.numeric(id)-id.c)!=0) stop(\"The ID variables needs to be numeric and ordered from 1:N.\")\n\n  x<-model.matrix(fit, data=fit$data   )\n\n  ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)\n\n\n\n  ###start gof\n\n\n\n  resI<-residuals(fit, level = 1  )\n\n\n  resP<-residuals(fit, level = 0  )\n\n  estI<-fitted(fit,level=1)\n  estP<-fitted(fit,level=0)\n\n  orI<-order(estI)\n  orP<-order(estP)\n\n\n\n  vc<-VarCorr(fit)\n  sigma.est<-as.numeric(vc[nrow(vc),1])\n\n  D<-getVarCov(fit)\n\n  beta.f<-fixef(fit)\n\n  V<-list()\n  V.i<-list()\n  Z<-list()\n  Xi<-list()\n  Zb<-list()\n  H<-matrix(0,ncol=ncol(x),nrow=ncol(x))\n  for (gg in 1:N){\n    if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]\n    if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)\n    I<-diag(rep(1),n[[gg]])\n    V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I\n    V.i[[gg]]<-V[[gg]]%^%(-1)\n    if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]\n    if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)\n\n  }\n\n  H.i<-solve(H)\n\n\n  A<-list()\n  B<-list()\n\n  res.i.c<-resI\n\n  mm=0\n  for (gg in 1:N){\n    for (jj in 1:N){\n      mm=mm+1\n\n\n      if (jj==gg){\n\n        zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])\n        cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])\n\n        #A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n        #B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])\n\n        vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz\n\n        A[[mm]]<-sigma.est*vzd\n        B[[mm]]<-zdz %*%vzd\n      } else {\n\n        zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])\n        zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])\n        cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])\n\n        #A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n        #B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])\n\n        vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj\n\n        A[[mm]]<--sigma.est*vzdj\n        B[[mm]]<--zdzg %*%vzdj\n\n\n      }\n\n    }}\n\n  aa<-bb<-list()\n  mm=0\n\n  for (gg in 1:N){\n\n    for (jj in 1:N){\n      mm=mm+1\n      if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])\n      if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])\n    }}\n\n  for (gg in 1:N){\n    if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])\n    if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])\n\n  }\n\n\n  Zb<-matrix(estI-estP,ncol=1)\n\n  if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb\n  #if (residuals==\"individual\") res.i.c<-resI-AA%*%ginv(BB)%*%estI else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%estI\n\n\n\n  V.ii.inv<-list()\n  V.ii<-list()\n  S.i<-list()\n\n\n  respermute<-NA\n  resIst<-NA\n  resPst<-NA\n  for (gg in 1:N){\n    I<-diag(rep(1,n[gg]))\n\n    V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)\n    V.ii[[gg]]<-V[[gg]]%^%(0.5)\n\n    resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMp2<-V.ii.inv[[gg]]%*%resPMp\n\n    respermute<-c(respermute,resPMp2)\n\n    if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))\n    if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])\n\n    resPMpC<-matrix(res.i.c[id==gg],ncol=1,nrow=n[gg],byrow=F)\n    resPMpC2<-S.i[[gg]]%*%resPMpC\n    resPMpC2<-resPMpC2\n\n    resIst<-c(resIst,resPMpC2)\n\n\n  }\n\n  respermute<-respermute[-1]\n  resIst<-resIst[-1]\n\n\n  resoI2<-resIst[orI]\n  t01<- estI\n\n  for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){\n    ig<-which(round(t01[orI],10)==round(ii,10))\n    resoI2[ig]<-sum(resoI2[ig])/length(ig)\n  }\n\n  WI2<-1/sqrt(N )*cumsum(resoI2)\n\n  WsI2 <-list()\n  estIm<-list()\n\n\n\n\n  iiii=0\n\n  while (iiii < M){\n\n\n    if (verbose) print(paste(\"Iteration: \",iiii,sep=\"\"))\n\n    if (type==\"sign.flip\"){\n\n      smp<-sample(c(-1,1),size=sum(n),replace=TRUE)\n\n      ys<-NA\n      for (gg in 1:N){\n        ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))\n      }\n      ys<-ys[-1] } else {\n\n        ys<-NA\n        for (gg in 1:N){\n\n          if (n[gg]==1) smp<-1 else smp<-sample(1:n[gg])\n          ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute[id==gg])[smp]   )  )\n        }\n        ys<-ys[-1]\n\n      }\n\n    datas<-fit$data\n    datas[,as.character(fit$call$fixed)[2]]<-ys\n\n\n\n    fits<-suppressWarnings(update(fit,data=datas))\n\n\n\n    sim.proc<-try(get.sim.proc.O.test.type2(fits, residuals=residuals,std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,n=n,N=N,x=x,ZZ=ZZ,id=id, est.original=estI,or.original=orI,A=AA,B=BB),silent = TRUE)\n\n    if (class(sim.proc)!=\"try-error\"){\n      iiii=iiii+1\n      WsI2[[iiii]]<-sim.proc[[1]]\n      estIm[[iiii]]<-sim.proc[[2]]\n\n\n    }\n\n\n\n  } #end while\n\n\n\n\n\n\n\n  res<-list(O=WI2,F=NULL,Om=WsI2,Fm=NULL,Fs=NULL,Fsm=NULL,predO=estI,predOm=estIm,predF=NULL,predFm=NULL,predFs=NULL,predFsm=NULL)\n  class(res)<-\"gofLMM\"\n  res\n\n\n} #end of function\n",
    "created" : 1562306852196.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2769556040",
    "id" : "2F7D9776",
    "lastKnownWriteTime" : 1567578264,
    "last_content_update" : 1567578264843,
    "path" : "E:/dropbox/Dropbox (MF Uni LJ)/gofLinearMixedModel/package/gofLMM/R/functions_gofLMM.R",
    "project_path" : "R/functions_gofLMM.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}