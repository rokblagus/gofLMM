resm.clust<-matrix(res.clust,ncol=4,byrow=T)
colnames(resm.ind)<-colnames(resm.clust)<-c("O.KS","O.CvM","F.KS","F.CvM")
rownames(resm.ind)<-rownames(resm.clust)<-c("Simulation.Pan","sign.flip")
list(results.ind=res.ind,results.matrix.ind=resm.ind,results.clust=res.clust,results.matrix.clust=resm.clust)
} #end of function
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
library(gofLMM2)
library(gofLMM)
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
smp<-sample(c(-1,1),size=1)
smp
smp<-sample(c(-1,1),size=1)
smp
smp<-sample(c(-1,1),size=1)
smp
library(gofLMM)
library(gofLMM)
detach("package:gofLMM", unload = TRUE)
library(gofLMM)
(sqrt(5)+1)/(2*sqrt(5))
p<-(sqrt(5)+1)/(2*sqrt(5))
p2<--(sqrt(5)-1)/(2)
p
p2
p<-(sqrt(5)+1)/(2*sqrt(5))
p2<-(sqrt(5)-1)/(2*sqrt(5))
p
p2
p+p2
p1<-(sqrt(5)+1)/(2*sqrt(5))
p2<-(sqrt(5)-1)/(2*sqrt(5))
x1<--(sqrt(5)-1)/2
x2<-(sqrt(5)+1)/2
p1
p2
x1
x2
p1<-(sqrt(5)+1)/(2*sqrt(5))
p2<-(sqrt(5)-1)/(2*sqrt(5))
x1<--(sqrt(5)-1)/2
x2<-(sqrt(5)+1)/2
y<-rbinom(n,size=1,prob=p2)
y
table(y)
12/n
n
n=100
p1<-(sqrt(5)+1)/(2*sqrt(5))
p2<-(sqrt(5)-1)/(2*sqrt(5))
x1<--(sqrt(5)-1)/2
x2<-(sqrt(5)+1)/2
y<-rbinom(n,size=1,prob=p2)
y
sum(y)
p2
my.mammen<-function(n){
p1<-(sqrt(5)+1)/(2*sqrt(5))
p2<-(sqrt(5)-1)/(2*sqrt(5))
x1<--(sqrt(5)-1)/2
x2<-(sqrt(5)+1)/2
y<-rbinom(n,size=1,prob=p2)
y[y==0]<-x1
y[y==1]<-x2
y
}
mean(my.mammen(10000))
var(my.mammen(10000))
var(my.mammen(1000000))
mean(my.mammen(1000000))
mean(my.mammen(100000000))
var(my.mammen(100000000))
library(gofLMM)
library(gofLMM)
library(gofLMM)
remove.packages("gofLMM")
install.packages("C:/Users/rblagus/Dropbox (MF Uni LJ)/gofLinearMixedModel/package/gofLMM_6.0.0.zip", repos = NULL, type = "win.binary")
library(gofLMM)
?gof.lmm
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=TRUE,use.mammen=TRUE,force.permutation.with=FALSE,verbose=TRUE)
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE,flip.cluster=TRUE,use.mammen=TRUE)
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=TRUE,force.permutation.with=FALSE,verbose=TRUE,flip.cluster=TRUE)
library(gofLMM)
?gof.lmm
gof.lmm()
gof.lmm
library(gofLMM)
library(gofLMM)
?gof.lmm
remove.packages("gofLMM")
install.packages("C:/Users/rblagus/Dropbox (MF Uni LJ)/gofLinearMixedModel/package/gofLMM_7.0.0.zip", repos = NULL, type = "win.binary")
library(gofLMM)
?gof.lmm
library(gofLMM)
?gof.lmm
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)
plot.gofLMM(fit.gof,type=2,subset.M=NULL,xlab="",main="Example")
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE,use.sigmoid = TRUE)
gof.lmm
update.packages("gofLMM")
gof.lmm
gof.lmm()
gof.lmm
library(gofLMM)
library(MASS)
library(gofLMM)
library(nlme)
##sim. data function. allows for a single random effect where Z can either be column of ones or (and) one of the fixed effects covariates (in this case the D will be assumed diagonal). Desing can be unlabanced. Both error sources can be non-normal.
##this is only for longitudinal for a typical randomized study.
sim.data.cluster<-function(N,n,betas, norm.eps,var.eps=NULL,shape=NULL,scale=NULL,norm.re.intercept,var.re.intercept=NULL,shape.re.intercept=NULL,scale.re.intercept=NULL,sim.re.slope,
norm.re.slope=NULL,var.re.slope=NULL,shape.re.slope=NULL,scale.re.slope=NULL,sim.x2.qdr=FALSE,b.qdr=NULL){
yy<-NA
id<-NA
x1<-NA
x2<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-runif(n[gg])
x1<-c(x1,x11)
x22<-runif(n[gg])
x2<-c(x2,x22)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(var.re.intercept)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg],sd=sqrt(var.eps)) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(var.re.slope)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
if (sim.x2.qdr==FALSE)   y<-betas[1]+betas[2]*x11+betas[3]*x22+b+b2*x11+eps  else y<-betas[1]+betas[2]*x11+betas[3]*x22+b+b2*x11+eps+ b.qdr*x11**2
} else {
if (sim.x2.qdr==FALSE) y<-betas[1]+betas[2]*x11+betas[3]*x22+b+eps   else y<-betas[1]+betas[2]*x11+betas[3]*x22+b+eps+ b.qdr*x11**2
}
yy<-c(yy,y)
}
yy<-yy[-1]
x2<-x2[-1]
x1<-x1[-1]
id<-id[-1]
df<-data.frame(id=id,y=yy,x1=x1,x2=x2)
df
}
?gof.lmm
gof.lmm
