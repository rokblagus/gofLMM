for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
A<-list()
B<-list()
res.i.c<-resI
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==gg){
zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])
cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])
#A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
#B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz
A[[mm]]<-sigma.est*vzd
B[[mm]]<-zdz %*%vzd
} else {
zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])
zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])
cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])
#A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
#B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj
A[[mm]]<--sigma.est*vzdj
B[[mm]]<--zdzg %*%vzdj
}
}}
aa<-bb<-list()
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA-AA1
sum(AA-AA1)
sum(BB-BB1)
AA[1:5,1:5]
AA1[1:5,1:5]
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
A<-list()
B<-list()
res.i.c<-resI
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==gg){
zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])
cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])
#A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
#B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz
A[[mm]]<-sigma.est*vzd
B[[mm]]<-zdz %*%vzd
} else {
zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])
zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])
cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])
#A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
#B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj
A[[mm]]<--sigma.est*vzdj
B[[mm]]<--zdzg %*%vzdj
}
}}
aa<-bb<-list()
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA[1:10,1:10]
AA[1:5,1:5]
AA1[1:5,1:5]
AA-AA1
sum(AA-AA1)
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA1-AA
sum(AA1-AA)
p2<-( Vd-Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
A<-list()
B<-list()
res.i.c<-resI
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==gg){
zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])
cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])
#A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
#B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz
A[[mm]]<-sigma.est*vzd
B[[mm]]<-zdz %*%vzd
} else {
zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])
zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])
cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])
#A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
#B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj
A[[mm]]<--sigma.est*vzdj
B[[mm]]<--zdzg %*%vzdj
}
}}
aa<-bb<-list()
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
sum(BB1-BB)
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
sum(BB1-BB)
library(gofLMM)
N=50
n=rep(30,N)
betas=c(-1,0.25,0.5)
x.prob=0.4
norm.eps=TRUE
var.eps=1
shape=NULL
scale=NULL
norm.re.intercept=TRUE
var.re.intercept=0.5
shape.re.intercept=NULL
scale.re.intercept=NULL
sim.re.slope=TRUE
norm.re.slope=TRUE
var.re.slope=0.25
shape.re.slope=NULL
scale.re.slope=NULL
sim.x2.qdr=FALSE
b.qdr=0.25
fit.re.slope=TRUE
dat<-sim.data.cluster(N=N,n=n,betas=betas,norm.eps=norm.eps,var.eps=var.eps,shape=shape,scale=scale,norm.re.intercept=norm.re.intercept,var.re.intercept=var.re.intercept,shape.re.intercept=shape.re.intercept,
scale.re.intercept=scale.re.intercept,sim.re.slope=sim.re.slope,
norm.re.slope=norm.re.slope,var.re.slope=var.re.slope,shape.re.slope=shape.re.slope,scale.re.slope=scale.re.slope,sim.x2.qdr=sim.x2.qdr,b.qdr=b.qdr)
if (fit.re.slope==TRUE) fit<-lme(y~x1+x2,random=~x1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE)) else fit<-lme(y~x1+x2,random=~1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE))
gof<-gof.lmm.O.test(fit,"individual",2, FALSE,"sign.flip",10,FALSE,verbose=TRUE)
residuals="individual"
std.type=2
use.correction.for.imbalance=FALSE
type="sign.flip"
M=100
order.by.original=FALSE
verbose=FALSE
if (is.null(fit$data)) stop("Model was fitted with keep.data=FALSE. Use keep.data=TRUE.")
if (verbose) cat("Using  \"verbose=TRUE \" slows down the algorithm, but it might feel faster. \n")
####preliminaries
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
dim(x)
res.i.c<-resI
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
NN<-nrow(x)
Vd<-Vdi<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
Vdi[ is,is]<-V.i[[i]]
}
IN<-diag(rep(1,NN))
#Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA<-sVdi%*%p2
BB<-p1%*%p2
Zb<-matrix(estI-estP,ncol=1)
if (residuals=="individual") res.i.c<-resI-AA%*%my.MP(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%my.MP(BB)%*%Zb
if (residuals=="individual") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb
#ii=1
N=100
n=rep(10,N)
betas=c(-1,0.25,0.5)
x.prob=0.4
norm.eps=TRUE
var.eps=1
shape=NULL
scale=NULL
norm.re.intercept=TRUE
var.re.intercept=0.5
shape.re.intercept=NULL
scale.re.intercept=NULL
sim.re.slope=TRUE
norm.re.slope=TRUE
var.re.slope=0.25
shape.re.slope=NULL
scale.re.slope=NULL
sim.x2.qdr=FALSE
b.qdr=0.25
fit.re.slope=TRUE
dat<-sim.data.cluster(N=N,n=n,betas=betas,norm.eps=norm.eps,var.eps=var.eps,shape=shape,scale=scale,norm.re.intercept=norm.re.intercept,var.re.intercept=var.re.intercept,shape.re.intercept=shape.re.intercept,
scale.re.intercept=scale.re.intercept,sim.re.slope=sim.re.slope,
norm.re.slope=norm.re.slope,var.re.slope=var.re.slope,shape.re.slope=shape.re.slope,scale.re.slope=scale.re.slope,sim.x2.qdr=sim.x2.qdr,b.qdr=b.qdr)
if (fit.re.slope==TRUE) fit<-lme(y~x1+x2,random=~x1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE)) else fit<-lme(y~x1+x2,random=~1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE))
gof<-gof.lmm.O.test(fit,"individual",2, FALSE,"sign.flip",10,FALSE,verbose=TRUE)
summary.gofLMM.testO(gof)
plot(gof)
gof2<-gof.lmm.O.test.type2(fit,"individual",2, FALSE,"sign.flip",10,verbose=TRUE)
summary.gofLMM.testO(gof2)
plot(gof2)
library(gofLMM)
library(gofLMM)
library(gofLMM)
library(gofLMM)
library(gofLMM)
?gof.lmmž
?gof.lmm
library(gofLMM)
?gof.lmm
library(gofLMM)
