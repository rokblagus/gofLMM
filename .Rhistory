for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA-AA1
sum(AA-AA1)
sum(BB-BB1)
AA[1:5,1:5]
AA1[1:5,1:5]
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
A<-list()
B<-list()
res.i.c<-resI
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==gg){
zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])
cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])
#A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
#B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz
A[[mm]]<-sigma.est*vzd
B[[mm]]<-zdz %*%vzd
} else {
zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])
zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])
cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])
#A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
#B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj
A[[mm]]<--sigma.est*vzdj
B[[mm]]<--zdzg %*%vzdj
}
}}
aa<-bb<-list()
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA[1:10,1:10]
AA[1:5,1:5]
AA1[1:5,1:5]
AA-AA1
sum(AA-AA1)
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd+Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
AA1-AA
sum(AA1-AA)
p2<-( Vd-Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
A<-list()
B<-list()
res.i.c<-resI
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==gg){
zdz<-  Z[[gg]]%*%D%*%t(Z[[gg]])
cpd<-Xi[[gg]]%*%H.i%*%t(Xi[[gg]])
#A[[mm]]<-sigma.est*V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
#B[[mm]]<-Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%( V[[gg]]- Xi[[gg]]%*%H.i%*%t(Xi[[gg]]) )%*%V.i[[gg]]%*%Z[[gg]]%*%D%*%t(Z[[gg]])
vzd<-V.i[[gg]]%*%( V[[gg]]- cpd )%*%V.i[[gg]]%*%zdz
A[[mm]]<-sigma.est*vzd
B[[mm]]<-zdz %*%vzd
} else {
zdzj<-Z[[jj]]%*%D%*%t(Z[[jj]])
zdzg<-Z[[gg]]%*%D%*%t(Z[[gg]])
cpdj<-Xi[[gg]]%*%H.i%*%t(Xi[[jj]])
#A[[mm]]<--sigma.est*V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
#B[[mm]]<--Z[[gg]]%*%D%*%t(Z[[gg]]) %*%V.i[[gg]]%*%(  Xi[[gg]]%*%H.i%*%t(Xi[[jj]]) )%*%V.i[[jj]]%*%Z[[jj]]%*%D%*%t(Z[[jj]])
vzdj<-V.i[[gg]]%*%(  cpdj )%*%V.i[[jj]]%*%zdzj
A[[mm]]<--sigma.est*vzdj
B[[mm]]<--zdzg %*%vzdj
}
}}
aa<-bb<-list()
mm=0
for (gg in 1:N){
for (jj in 1:N){
mm=mm+1
if (jj==1) aa[[gg]]<-A[[mm]] else aa[[gg]]<-cbind(aa[[gg]],A[[mm]])
if (jj==1) bb[[gg]]<-B[[mm]] else bb[[gg]]<-cbind(bb[[gg]],B[[mm]])
}}
for (gg in 1:N){
if (gg==1) AA<-aa[[gg]] else AA<-rbind(AA,aa[[gg]])
if (gg==1) BB<-bb[[gg]] else BB<-rbind(BB,bb[[gg]])
}
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
sum(BB1-BB)
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
p<-ncol(x)
Xd<-matrix(0,ncol=p*N,nrow=NN)
for (i in 1:N){
is<-which(id==i)
id<-c(  (p*(i-1)+1) :(p*i) )
Xd[id,is]<-x[is,]
}
M11<-matrix(1,N,N)
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-Xd%*%kronecker(M11,H.i)%*%t(Xd)   )%*%p1
AA1<-sVdi%*%p2
BB1<-p1%*%p2
sum(AA1-AA)
sum(BB1-BB)
library(gofLMM)
N=50
n=rep(30,N)
betas=c(-1,0.25,0.5)
x.prob=0.4
norm.eps=TRUE
var.eps=1
shape=NULL
scale=NULL
norm.re.intercept=TRUE
var.re.intercept=0.5
shape.re.intercept=NULL
scale.re.intercept=NULL
sim.re.slope=TRUE
norm.re.slope=TRUE
var.re.slope=0.25
shape.re.slope=NULL
scale.re.slope=NULL
sim.x2.qdr=FALSE
b.qdr=0.25
fit.re.slope=TRUE
dat<-sim.data.cluster(N=N,n=n,betas=betas,norm.eps=norm.eps,var.eps=var.eps,shape=shape,scale=scale,norm.re.intercept=norm.re.intercept,var.re.intercept=var.re.intercept,shape.re.intercept=shape.re.intercept,
scale.re.intercept=scale.re.intercept,sim.re.slope=sim.re.slope,
norm.re.slope=norm.re.slope,var.re.slope=var.re.slope,shape.re.slope=shape.re.slope,scale.re.slope=scale.re.slope,sim.x2.qdr=sim.x2.qdr,b.qdr=b.qdr)
if (fit.re.slope==TRUE) fit<-lme(y~x1+x2,random=~x1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE)) else fit<-lme(y~x1+x2,random=~1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE))
gof<-gof.lmm.O.test(fit,"individual",2, FALSE,"sign.flip",10,FALSE,verbose=TRUE)
residuals="individual"
std.type=2
use.correction.for.imbalance=FALSE
type="sign.flip"
M=100
order.by.original=FALSE
verbose=FALSE
if (is.null(fit$data)) stop("Model was fitted with keep.data=FALSE. Use keep.data=TRUE.")
if (verbose) cat("Using  \"verbose=TRUE \" slows down the algorithm, but it might feel faster. \n")
####preliminaries
id<-fit$data[,names(formula(fit$modelStruct$reStr))]
N<-length(unique(id))
n<-table(id)
id.c<-NA
for (ii in 1:N){
id.c<-c(id.c,rep(ii,n[ii]))
}
id.c<-id.c[-1]
if (sum(as.numeric(id)-id.c)!=0) stop("The ID variables needs to be numeric and ordered from 1:N.")
x<-model.matrix(fit, data=fit$data   )
ZZ<- model.matrix(formula(fit$modelStruct$reStr)[[1]],data=fit$data)
###start gof
resI<-residuals(fit, level = 1  )
resP<-residuals(fit, level = 0  )
estI<-fitted(fit,level=1)
estP<-fitted(fit,level=0)
orI<-order(estI)
orP<-order(estP)
vc<-VarCorr(fit)
sigma.est<-as.numeric(vc[nrow(vc),1])
D<-getVarCov(fit)
beta.f<-fixef(fit)
V<-list()
V.i<-list()
Z<-list()
Xi<-list()
Zb<-list()
H<-matrix(0,ncol=ncol(x),nrow=ncol(x))
for (gg in 1:N){
if (ncol(ZZ)==1) Z[[gg]]<-matrix(ZZ[id==gg,],ncol=1) else Z[[gg]]<-ZZ[id==gg,]
if (n[gg]==1) Z[[gg]]<-matrix(Z[[gg]],nrow=1)
I<-diag(rep(1),n[[gg]])
V[[gg]]<-Z[[gg]]%*%D%*%t(Z[[gg]])+sigma.est*I
V.i[[gg]]<-V[[gg]]%^%(-1)
if (n[gg]!=1) H<-H+t(x[id==gg,])%*%V.i[[gg]]%*%x[id==gg,] else H<-H+matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%x[id==gg,]
if (n[gg]!=1) Xi[[gg]]<-x[id==gg,] else Xi[[gg]]<-matrix(x[id==gg,],nrow=1)
}
H.i<-solve(H)
dim(x)
res.i.c<-resI
NN<-nrow(x)
Vd<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
}
IN<-diag(rep(1,NN))
Vdi<-solve(Vd)
NN<-nrow(x)
Vd<-Vdi<-matrix(0,NN,NN)
for (i in 1:N){
is<-which(id==i)
Vd[ is,is]<-V[[i]]
Vdi[ is,is]<-V.i[[i]]
}
IN<-diag(rep(1,NN))
#Vdi<-solve(Vd)
sVdi<-sigma.est*Vdi
p1<-(IN-sVdi)
p2<-( Vd-x%*%H.i%*%t(x)   )%*%p1
AA<-sVdi%*%p2
BB<-p1%*%p2
Zb<-matrix(estI-estP,ncol=1)
if (residuals=="individual") res.i.c<-resI-AA%*%my.MP(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%my.MP(BB)%*%Zb
if (residuals=="individual") res.i.c<-resI-AA%*%ginv(BB)%*%Zb else res.i.c<-resP-(AA+BB)%*%ginv(BB)%*%Zb
#ii=1
N=100
n=rep(10,N)
betas=c(-1,0.25,0.5)
x.prob=0.4
norm.eps=TRUE
var.eps=1
shape=NULL
scale=NULL
norm.re.intercept=TRUE
var.re.intercept=0.5
shape.re.intercept=NULL
scale.re.intercept=NULL
sim.re.slope=TRUE
norm.re.slope=TRUE
var.re.slope=0.25
shape.re.slope=NULL
scale.re.slope=NULL
sim.x2.qdr=FALSE
b.qdr=0.25
fit.re.slope=TRUE
dat<-sim.data.cluster(N=N,n=n,betas=betas,norm.eps=norm.eps,var.eps=var.eps,shape=shape,scale=scale,norm.re.intercept=norm.re.intercept,var.re.intercept=var.re.intercept,shape.re.intercept=shape.re.intercept,
scale.re.intercept=scale.re.intercept,sim.re.slope=sim.re.slope,
norm.re.slope=norm.re.slope,var.re.slope=var.re.slope,shape.re.slope=shape.re.slope,scale.re.slope=scale.re.slope,sim.x2.qdr=sim.x2.qdr,b.qdr=b.qdr)
if (fit.re.slope==TRUE) fit<-lme(y~x1+x2,random=~x1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE)) else fit<-lme(y~x1+x2,random=~1|id,data=dat,method="REML",control=lmeControl( returnObject = TRUE))
gof<-gof.lmm.O.test(fit,"individual",2, FALSE,"sign.flip",10,FALSE,verbose=TRUE)
summary.gofLMM.testO(gof)
plot(gof)
gof2<-gof.lmm.O.test.type2(fit,"individual",2, FALSE,"sign.flip",10,verbose=TRUE)
summary.gofLMM.testO(gof2)
plot(gof2)
library(gofLMM)
library(gofLMM)
library(gofLMM)
library(gofLMM)
library(gofLMM)
?gof.lmmž
?gof.lmm
library(gofLMM)
?gof.lmm
library(gofLMM)
library(gofLMM)
library(gofLMM)
library(gofLMM)
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
fit.gof<-gof.lmm(fit,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=outcome~x2,type= "simulation" ,M=25,order.by.original=FALSE,force.permutation.with=FALSE,verbose=TRUE)
plot.gofLMM(fit.gof,type=2,subset.M=NULL,xlab="",main="Example")
summary.gofLMM(fit.gof)
library(nlme)
data(Orthodont)
Orthodont$Subject<- rep(1:27,each=4)
fm1<-lme(distance~age,random=~1|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method="REML")
gof.fm1<-gof.lmm(fm1,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= "sign.flip" ,M=500,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=TRUE)
plot.gofLMM(gof.fm1,type=2,subset.M=NULL,xlab="",main="Orthodont, model 1")
summary.gofLMM(gof.fm1)
fm1.1<-lme(distance~age,random=~age|Subject,data=Orthodont,control=lmeControl( returnObject = TRUE),method="REML")
gof.fm1.1<-gof.lmm(fm1.1,residuals= "individual" ,std.type=2,use.correction.for.imbalance=FALSE,subset.fix=NULL,type= "sign.flip" ,M=500,order.by.original=FALSE,force.permutation.with.O=FALSE,verbose=TRUE)
plot.gofLMM(gof.fm1.1 ,type=2,subset.M=NULL,xlab="",main="Orthodont, model 1.1")
summary.gofLMM(gof.fm1.1)
library(gofLMM)
install_github("rokblaugs/gofLMM")
library(devtools)
install_github("rokblaugs/gofLMM")
install_github("rokblagus/gofLMM")
install_github("rokblagus/gofLMM")
library(devtools)
install_github("rokblagus/gofLMM")
install_github("rokblagus/gofLMM",force=TRUE)
library(gofLMM)
install_github("rokblagus/gofLMM",force=TRUE)
install_github("Pakillo/grateful")
cite_packages()
citation(gofLMM)
citation("gofLMM")
