I<-diag(rep(1,n[gg]))
J.ind[[gg]]<-sigma.est*V.i[[gg]]-(A[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]
J.clust[[gg]]<-I-(A[[gg]]+B[[gg]])%*%ginv(B[[gg]])%*% Z[[gg]]%*%D%*%t(Z[[gg]])%*%V.i[[gg]]
res.i.c.ind[id==gg]<- J.ind[[gg]]%*% resI[id==gg]
res.i.c.clust[id==gg]<- J.clust[[gg]]%*% resP[id==gg]
}
V.ii.inv<-list()
V.ii<-list()
S.i<-list()
res.i.c2.ind<-resI
res.i.c2.clust<-resP
respermute<-NA
resIst.ind<-NA
resPst.ind<-NA
resIst.clust<-NA
resPst.clust<-NA
for (gg in 1:N){
I<-diag(rep(1,n[gg]))
V.ii.inv[[gg]]<-V[[gg]]%^%(-0.5)
V.ii[[gg]]<-V[[gg]]%^%(0.5)
resPMp<-matrix(resP[id==gg],ncol=1,nrow=n[gg],byrow=F)
resPMp2<-V.ii.inv[[gg]]%*%resPMp
respermute<-c(respermute,resPMp2)
if (std.type==2) S.i[[gg]]<-V.ii.inv[[gg]] else S.i[[gg]]<-  1/sqrt( sigma.est )*diag(rep(1,n[gg]))
if (use.correction.for.imbalance==TRUE) S.i[[gg]]<-S.i[[gg]]/sqrt(n[gg])
resPMpC<-matrix(res.i.c.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)
resPMpC2<-S.i[[gg]]%*%resPMpC
resPMpC2<-resPMpC2
resIst.ind<-c(resIst.ind,resPMpC2)
resPMpC<-matrix(res.i.c.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)
resPMpC2<-S.i[[gg]]%*%resPMpC
resPMpC2<-resPMpC2
resIst.clust<-c(resIst.clust,resPMpC2)
resPMpCP<-matrix(res.i.c2.ind[id==gg],ncol=1,nrow=n[gg],byrow=F)
resPMpC2P<-S.i[[gg]]%*%resPMpCP
resPMpC2P<-resPMpC2P
resPst.ind<-c(resPst.ind,resPMpC2P)
resPMpCP<-matrix(res.i.c2.clust[id==gg],ncol=1,nrow=n[gg],byrow=F)
resPMpC2P<-S.i[[gg]]%*%resPMpCP
resPMpC2P<-resPMpC2P
resPst.clust<-c(resPst.clust,resPMpC2P)
}
respermute<-respermute[-1]
resIst.ind<-resIst.ind[-1]
resPst.ind<-resPst.ind[-1]
resIst.clust<-resIst.clust[-1]
resPst.clust<-resPst.clust[-1]
resoI2<-resIst.ind[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
resoI2[ig]<-sum(resoI2[ig])/length(ig)
}
WI2.ind<-1/sqrt(N )*cumsum(resoI2)
resoP2<-resPst.ind[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
resoP2[ig]<-sum(resoP2[ig])/length(ig)
}
WP2.ind<-1/sqrt(N )*cumsum(resoP2)
resoI2<-resIst.clust[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
resoI2[ig]<-sum(resoI2[ig])/length(ig)
}
WI2.clust<-1/sqrt(N )*cumsum(resoI2)
resoP2<-resPst.clust[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
resoP2[ig]<-sum(resoP2[ig])/length(ig)
}
WP2.clust<-1/sqrt(N )*cumsum(resoP2)
####start sim/sign/permuted proces
###simulation, Pan approach
WsP2.ind<- WsI2.ind <-list()
WsP2.clust<- WsI2.clust <-list()
for (iiii in 1:M){
if (verbose) print(paste("Simulation Pan: ",iiii,sep=""))
newres<-NA
for (gg in 1:N){
smp<-rnorm(1)
newres<-c(newres, ( (resP*smp)[id==gg]))
}
newres<-newres[-1]
##prvi del procesa
prvi.del.p.ind<-prvi.del.ind<-prvi.del.p.clust<-prvi.del.clust<-NA
for (gg in 1:N){
prvi.del.ind<-c(prvi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%(newres[id==gg]))
prvi.del.clust<-c(prvi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%(newres[id==gg]))
prvi.del.p.clust<-c(prvi.del.p.clust,S.i[[gg]]%*%(newres[id==gg]))
prvi.del.p.ind<-c(prvi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%(newres[id==gg]))
}
prvi.del.ind<-prvi.del.ind[-1]
prvi.del.p.ind<-prvi.del.p.ind[-1]
prvi.del.clust<-prvi.del.clust[-1]
prvi.del.p.clust<-prvi.del.p.clust[-1]
prvi.del.o<-prvi.del.ind[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)
}
Iind<-1/sqrt(N)*cumsum(prvi.del.o)
prvi.del.o<-prvi.del.clust[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
prvi.del.o[ig]<-sum(prvi.del.o[ig])/length(ig)
}
Iclust<-1/sqrt(N)*cumsum(prvi.del.o)
prvi.del.op<-prvi.del.p.ind[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)
}
Ipind<-1/sqrt(N)*cumsum(prvi.del.op)
prvi.del.op<-prvi.del.p.clust[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
prvi.del.op[ig]<-sum(prvi.del.op[ig])/length(ig)
}
Ipclust<-1/sqrt(N)*cumsum(prvi.del.op)
dva.1<-matrix(0,ncol=1,nrow=ncol(x))
for (gg  in 1:N){
if (n[gg]!=1) dva.1<-dva.1+  t(x[id==gg,])%*%V.i[[gg]]%*%(newres[id==gg]) else dva.1<-dva.1+  matrix(x[id==gg,],ncol=1)%*%V.i[[gg]]%*%(newres[id==gg])
}
drugi.del.p.ind<-drugi.del.ind<-drugi.del.p.clust<-drugi.del.clust<-NA
for (gg in 1:N){
drugi.del.ind<-c(drugi.del.ind,S.i[[gg]]%*%J.ind[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)
drugi.del.clust<-c(drugi.del.clust,S.i[[gg]]%*%J.clust[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)
drugi.del.p.clust<-c(drugi.del.p.clust,S.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)
drugi.del.p.ind<-c(drugi.del.p.ind,sigma.est*S.i[[gg]]%*%V.i[[gg]]%*%x[id==gg,]%*%H.i%*%dva.1)
}
drugi.del.ind<-drugi.del.ind[-1]
drugi.del.p.ind<-drugi.del.p.ind[-1]
drugi.del.clust<-drugi.del.clust[-1]
drugi.del.p.clust<-drugi.del.p.clust[-1]
drugi.del.o<-drugi.del.ind[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)
}
drugi.del.op<-drugi.del.p.ind[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)
}
IIind<-1/sqrt( N)*cumsum(drugi.del.o)
IIpind<-1/sqrt( N)*cumsum(drugi.del.op)
drugi.del.o<-drugi.del.clust[orI]
t01<- estI
for (ii in as.numeric(names(table(t01[orI]))[which(table(t01[orI])>1)])){
ig<-which(round(t01[orI],10)==round(ii,10))
drugi.del.o[ig]<-sum(drugi.del.o[ig])/length(ig)
}
drugi.del.op<-drugi.del.p.clust[orP]
t01P<- estP
for (ii in as.numeric(names(table(t01P[orP]))[which(table(t01P[orP])>1)])){
ig<-which(round(t01P[orP],10)==round(ii,10))
drugi.del.op[ig]<-sum(drugi.del.op[ig])/length(ig)
}
IIclust<-1/sqrt( N)*cumsum(drugi.del.o)
IIpclust<-1/sqrt( N)*cumsum(drugi.del.op)
WsI2.ind[[iiii]]<-Iind-IIind
WsP2.ind[[iiii]]<-Ipind-IIpind
WsI2.clust[[iiii]]<-Iclust-IIclust
WsP2.clust[[iiii]]<-Ipclust-IIpclust
}
res.sim.ind<-c(
p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),
p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),
p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),
p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )
)
res.sim.clust<-c(
p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),
p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),
p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),
p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )
)
WsP2.ind<- WsI2.ind <-list()
WsP2.clust<- WsI2.clust <-list()
for (iiii in 1:M){
if (verbose) print(paste("Sign-flip: ",iiii,sep=""))
smp<-sample(c(-1,1),size=1)
ys<-NA
for (gg in 1:N){
ys<-c(ys,estP[id==gg]+  V.ii[[gg]]%*%( (respermute*smp)[id==gg]))
}
ys<-ys[-1]
datas<-fit$data
datas[,as.character(fit$call$fixed)[2]]<-ys
fits<-suppressWarnings(update(fit,data=datas))
sim.proc<-get.sim.proc.fast.ororg(fits, std.type=std.type,use.correction.for.imbalance=use.correction.for.imbalance,
n=n,N=N,x=x,ZZ=ZZ,id=id,fittedI=estI, or.fittedI=orI,fittedP=estP,or.fittedP=orP)
WsI2.ind[[iiii]]<-sim.proc[[1]]
WsP2.ind[[iiii]]<-sim.proc[[2]]
WsI2.clust[[iiii]]<-sim.proc[[3]]
WsP2.clust[[iiii]]<-sim.proc[[4]]
} #end for
res.sign.ind<-c(
p.val(  KS(WI2.ind),unlist(lapply(WsI2.ind,KS)) ),
p.val(  CvM(WI2.ind),unlist(lapply(WsI2.ind,CvM)) ),
p.val(  KS(WP2.ind),unlist(lapply(WsP2.ind,KS)) ),
p.val(  CvM(WP2.ind),unlist(lapply(WsP2.ind,CvM)) )
)
res.sign.clust<-c(
p.val(  KS(WI2.clust),unlist(lapply(WsI2.clust,KS)) ),
p.val(  CvM(WI2.clust),unlist(lapply(WsI2.clust,CvM)) ),
p.val(  KS(WP2.clust),unlist(lapply(WsP2.clust,KS)) ),
p.val(  CvM(WP2.clust),unlist(lapply(WsP2.clust,CvM)) )
)
res.ind<-c(res.sim.ind,   res.sign.ind)
res.clust<-c(res.sim.clust,res.sign.clust)
names(res.ind)<-names(res.clust)<-c(
paste("Sim",c("O.KS","O.CvM","F.KS","F.CvM"),sep=":"),
paste("Sign",c("O.KS","O.CvM","F.KS","F.CvM"),sep=":")
)
resm.ind<-matrix(res.ind,ncol=4,byrow=T)
resm.clust<-matrix(res.clust,ncol=4,byrow=T)
colnames(resm.ind)<-colnames(resm.clust)<-c("O.KS","O.CvM","F.KS","F.CvM")
rownames(resm.ind)<-rownames(resm.clust)<-c("Simulation.Pan","sign.flip")
list(results.ind=res.ind,results.matrix.ind=resm.ind,results.clust=res.clust,results.matrix.clust=resm.clust)
} #end of function
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
library(gofLMM2)
library(gofLMM)
N=50
set.seed(1)
n<-floor(runif(N,min=1,max=15)) #imbalanced
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
betas<-c(1,1,1,15) #don't change! #the last one is only used whe omit.important.predictor=TRUE
norm.eps<-FALSE
shape=0.5
scale=1
norm.re.intercept<-FALSE
shape.re.intercept=0.5
scale.re.intercept=1
norm.re.slope<-FALSE
shape.re.slope=0.5
scale.re.slope=1
sim.re.slope=FALSE
over.parameterized.model=FALSE #i.e. fit a variable which is not used when generating the data
omit.important.predictor=FALSE
yy<-NA
x22<-NA
id<-NA
x1<-NA
for (gg in 1:N){
id<-c(id,rep(gg,each=n[gg]))
x11<-rep(rbinom(1,size=1,prob=0.4),each=n[gg])
x1<-c(x1,x11)
if (norm.re.intercept==TRUE) re.int<-rnorm(1,sd=sqrt(2)) else re.int<-rgamma(1,shape=shape.re.intercept,scale=scale.re.intercept)-shape.re.intercept*scale.re.intercept
b<-rep(re.int,each=n[gg])
if (norm.re.slope==TRUE) re.slope<-rnorm(1,sd=sqrt(1)) else re.slope<-rgamma(1,shape=shape.re.slope,scale=scale.re.slope)-shape.re.slope*scale.re.slope
b2<-rep(re.slope,each=n[gg])
x2<-1:n[gg]
x4<-runif(n[gg])
if (norm.eps==TRUE) eps<-rnorm(n[gg]) else eps<-rgamma(n[gg],shape=shape,scale=scale)-shape*scale
if (sim.re.slope==TRUE) {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+b2*x2+eps+betas[4]*x4
} else {
if (omit.important.predictor==FALSE) y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps else y<-betas[1]+betas[2]*x2+betas[3]*(x11*x2)+b+eps+betas[4]*x4
}
yy<-c(yy,y)
x22<-c(x22,x2)
}
yy<-yy[-1]
x22<-x22[-1]
x1<-x1[-1]
id<-id[-1]
x4<-runif(sum(n))
aids.art<-data.frame(ptnt=id,outcome=yy,x1=x1,x2=x22,x4=x4)
library(nlme)
fit<-lme(fixed=outcome~ x2+x1:x2, data=aids.art, random=~x2|ptnt,control=lmeControl( returnObject = TRUE),method="REML" )
gof.lmm.sim.orderbyoriginal.type2(fit,std.type=2,use.correction.for.imbalance=FALSE,M=25,verbose=TRUE)
